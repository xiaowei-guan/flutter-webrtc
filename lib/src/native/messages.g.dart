// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v9.2.4), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

class SessionDescriptionMessage {
  SessionDescriptionMessage({
    this.sdp,
    this.type,
  });

  String? sdp;

  String? type;

  Object encode() {
    return <Object?>[
      sdp,
      type,
    ];
  }

  static SessionDescriptionMessage decode(Object result) {
    result as List<Object?>;
    return SessionDescriptionMessage(
      sdp: result[0] as String?,
      type: result[1] as String?,
    );
  }
}

class ConstraintsMessage {
  ConstraintsMessage({
    required this.constraints,
  });

  Map<String?, dynamic?> constraints;

  Object encode() {
    return <Object?>[
      constraints,
    ];
  }

  static ConstraintsMessage decode(Object result) {
    result as List<Object?>;
    return ConstraintsMessage(
      constraints: (result[0] as Map<Object?, Object?>?)!.cast<String?, dynamic?>(),
    );
  }
}

class ConfigurationMessage {
  ConfigurationMessage({
    required this.configurations,
  });

  Map<String?, dynamic?> configurations;

  Object encode() {
    return <Object?>[
      configurations,
    ];
  }

  static ConfigurationMessage decode(Object result) {
    result as List<Object?>;
    return ConfigurationMessage(
      configurations: (result[0] as Map<Object?, Object?>?)!.cast<String?, dynamic?>(),
    );
  }
}

class MediaStreamMessage {
  MediaStreamMessage({
    required this.id,
    required this.ownerTag,
    required this.audioTracks,
    required this.videoTracks,
  });

  String id;

  String ownerTag;

  List<AudioTrackMessage?> audioTracks;

  List<VideoTrackMessage?> videoTracks;

  Object encode() {
    return <Object?>[
      id,
      ownerTag,
      audioTracks,
      videoTracks,
    ];
  }

  static MediaStreamMessage decode(Object result) {
    result as List<Object?>;
    return MediaStreamMessage(
      id: result[0]! as String,
      ownerTag: result[1]! as String,
      audioTracks: (result[2] as List<Object?>?)!.cast<AudioTrackMessage?>(),
      videoTracks: (result[3] as List<Object?>?)!.cast<VideoTrackMessage?>(),
    );
  }
}

class AudioTrackMessage {
  AudioTrackMessage({
    required this.id,
    required this.label,
    required this.kind,
    required this.enabled,
    required this.settings,
  });

  String id;

  String label;

  String kind;

  bool enabled;

  AudioTrackSettingsMessage settings;

  Object encode() {
    return <Object?>[
      id,
      label,
      kind,
      enabled,
      settings.encode(),
    ];
  }

  static AudioTrackMessage decode(Object result) {
    result as List<Object?>;
    return AudioTrackMessage(
      id: result[0]! as String,
      label: result[1]! as String,
      kind: result[2]! as String,
      enabled: result[3]! as bool,
      settings: AudioTrackSettingsMessage.decode(result[4]! as List<Object?>),
    );
  }
}

class AudioTrackSettingsMessage {
  AudioTrackSettingsMessage({
    required this.deviceId,
    required this.kind,
    required this.autoGainControl,
    required this.echoCancellation,
    required this.noiseSuppression,
    required this.channelCount,
    required this.latency,
  });

  String deviceId;

  String kind;

  bool autoGainControl;

  bool echoCancellation;

  bool noiseSuppression;

  int channelCount;

  int latency;

  Object encode() {
    return <Object?>[
      deviceId,
      kind,
      autoGainControl,
      echoCancellation,
      noiseSuppression,
      channelCount,
      latency,
    ];
  }

  static AudioTrackSettingsMessage decode(Object result) {
    result as List<Object?>;
    return AudioTrackSettingsMessage(
      deviceId: result[0]! as String,
      kind: result[1]! as String,
      autoGainControl: result[2]! as bool,
      echoCancellation: result[3]! as bool,
      noiseSuppression: result[4]! as bool,
      channelCount: result[5]! as int,
      latency: result[6]! as int,
    );
  }
}

class VideoTrackMessage {
  VideoTrackMessage({
    required this.id,
    required this.label,
    required this.kind,
    required this.enabled,
    required this.settings,
  });

  String id;

  String label;

  String kind;

  bool enabled;

  VideoTrackSettingsMessage settings;

  Object encode() {
    return <Object?>[
      id,
      label,
      kind,
      enabled,
      settings.encode(),
    ];
  }

  static VideoTrackMessage decode(Object result) {
    result as List<Object?>;
    return VideoTrackMessage(
      id: result[0]! as String,
      label: result[1]! as String,
      kind: result[2]! as String,
      enabled: result[3]! as bool,
      settings: VideoTrackSettingsMessage.decode(result[4]! as List<Object?>),
    );
  }
}

class VideoTrackSettingsMessage {
  VideoTrackSettingsMessage({
    required this.deviceId,
    required this.kind,
    required this.width,
    required this.height,
    required this.frameRate,
  });

  String deviceId;

  String kind;

  int width;

  int height;

  int frameRate;

  Object encode() {
    return <Object?>[
      deviceId,
      kind,
      width,
      height,
      frameRate,
    ];
  }

  static VideoTrackSettingsMessage decode(Object result) {
    result as List<Object?>;
    return VideoTrackSettingsMessage(
      deviceId: result[0]! as String,
      kind: result[1]! as String,
      width: result[2]! as int,
      height: result[3]! as int,
      frameRate: result[4]! as int,
    );
  }
}

class MediaDeviceInfoMessage {
  MediaDeviceInfoMessage({
    required this.deviceId,
    this.groupId,
    this.kind,
    required this.label,
  });

  String deviceId;

  String? groupId;

  String? kind;

  String label;

  Object encode() {
    return <Object?>[
      deviceId,
      groupId,
      kind,
      label,
    ];
  }

  static MediaDeviceInfoMessage decode(Object result) {
    result as List<Object?>;
    return MediaDeviceInfoMessage(
      deviceId: result[0]! as String,
      groupId: result[1] as String?,
      kind: result[2] as String?,
      label: result[3]! as String,
    );
  }
}

class IceCandidateMessage {
  IceCandidateMessage({
    this.candidate,
    this.sdpMid,
    this.sdpMLineIndex,
  });

  String? candidate;

  String? sdpMid;

  int? sdpMLineIndex;

  Object encode() {
    return <Object?>[
      candidate,
      sdpMid,
      sdpMLineIndex,
    ];
  }

  static IceCandidateMessage decode(Object result) {
    result as List<Object?>;
    return IceCandidateMessage(
      candidate: result[0] as String?,
      sdpMid: result[1] as String?,
      sdpMLineIndex: result[2] as int?,
    );
  }
}

class StatsReportMessage {
  StatsReportMessage({
    this.id,
    this.type,
    this.timestamp,
    required this.values,
  });

  String? id;

  String? type;

  double? timestamp;

  Map<dynamic?, dynamic?> values;

  Object encode() {
    return <Object?>[
      id,
      type,
      timestamp,
      values,
    ];
  }

  static StatsReportMessage decode(Object result) {
    result as List<Object?>;
    return StatsReportMessage(
      id: result[0] as String?,
      type: result[1] as String?,
      timestamp: result[2] as double?,
      values: (result[3] as Map<Object?, Object?>?)!.cast<dynamic?, dynamic?>(),
    );
  }
}

class DataChannelMessage {
  DataChannelMessage({
    required this.channelId,
    required this.type,
    this.binary,
    this.text,
  });

  String channelId;

  String type;

  Uint8List? binary;

  String? text;

  Object encode() {
    return <Object?>[
      channelId,
      type,
      binary,
      text,
    ];
  }

  static DataChannelMessage decode(Object result) {
    result as List<Object?>;
    return DataChannelMessage(
      channelId: result[0]! as String,
      type: result[1]! as String,
      binary: result[2] as Uint8List?,
      text: result[3] as String?,
    );
  }
}

class DataChannelInitMessage {
  DataChannelInitMessage({
    required this.id,
    required this.negotiated,
    required this.binaryType,
    required this.protocol,
    required this.ordered,
    required this.maxRetransmitTime,
    required this.maxRetransmits,
  });

  int id;

  bool negotiated;

  String binaryType;

  String protocol;

  bool ordered;

  int maxRetransmitTime;

  int maxRetransmits;

  Object encode() {
    return <Object?>[
      id,
      negotiated,
      binaryType,
      protocol,
      ordered,
      maxRetransmitTime,
      maxRetransmits,
    ];
  }

  static DataChannelInitMessage decode(Object result) {
    result as List<Object?>;
    return DataChannelInitMessage(
      id: result[0]! as int,
      negotiated: result[1]! as bool,
      binaryType: result[2]! as String,
      protocol: result[3]! as String,
      ordered: result[4]! as bool,
      maxRetransmitTime: result[5]! as int,
      maxRetransmits: result[6]! as int,
    );
  }
}

class HeaderExtensionMessage {
  HeaderExtensionMessage({
    this.uri,
    this.id,
    this.encrypted,
  });

  String? uri;

  int? id;

  bool? encrypted;

  Object encode() {
    return <Object?>[
      uri,
      id,
      encrypted,
    ];
  }

  static HeaderExtensionMessage decode(Object result) {
    result as List<Object?>;
    return HeaderExtensionMessage(
      uri: result[0] as String?,
      id: result[1] as int?,
      encrypted: result[2] as bool?,
    );
  }
}

class RtpEncodingMessage {
  RtpEncodingMessage({
    required this.active,
    this.rid,
    this.maxBitrate,
    this.minBitrate,
    this.maxFramerate,
    this.numTemporalLayers,
    this.scaleResolutionDownBy,
    this.ssrc,
    this.scalabilityMode,
  });

  bool active;

  String? rid;

  int? maxBitrate;

  int? minBitrate;

  int? maxFramerate;

  int? numTemporalLayers;

  double? scaleResolutionDownBy;

  int? ssrc;

  String? scalabilityMode;

  Object encode() {
    return <Object?>[
      active,
      rid,
      maxBitrate,
      minBitrate,
      maxFramerate,
      numTemporalLayers,
      scaleResolutionDownBy,
      ssrc,
      scalabilityMode,
    ];
  }

  static RtpEncodingMessage decode(Object result) {
    result as List<Object?>;
    return RtpEncodingMessage(
      active: result[0]! as bool,
      rid: result[1] as String?,
      maxBitrate: result[2] as int?,
      minBitrate: result[3] as int?,
      maxFramerate: result[4] as int?,
      numTemporalLayers: result[5] as int?,
      scaleResolutionDownBy: result[6] as double?,
      ssrc: result[7] as int?,
      scalabilityMode: result[8] as String?,
    );
  }
}

class RtpCodecMessage {
  RtpCodecMessage({
    this.payloadType,
    this.name,
    this.kind,
    this.clockRate,
    this.numChannels,
    this.parameters,
  });

  int? payloadType;

  String? name;

  String? kind;

  int? clockRate;

  int? numChannels;

  Map<dynamic?, dynamic?>? parameters;

  Object encode() {
    return <Object?>[
      payloadType,
      name,
      kind,
      clockRate,
      numChannels,
      parameters,
    ];
  }

  static RtpCodecMessage decode(Object result) {
    result as List<Object?>;
    return RtpCodecMessage(
      payloadType: result[0] as int?,
      name: result[1] as String?,
      kind: result[2] as String?,
      clockRate: result[3] as int?,
      numChannels: result[4] as int?,
      parameters: (result[5] as Map<Object?, Object?>?)?.cast<dynamic?, dynamic?>(),
    );
  }
}

class RtpParametersMessage {
  RtpParametersMessage({
    this.transactionId,
    this.rtcp,
    this.headerExtensions,
    this.encodings,
    this.codecs,
  });

  String? transactionId;

  RTCParametersMessage? rtcp;

  List<HeaderExtensionMessage?>? headerExtensions;

  List<RtpEncodingMessage?>? encodings;

  List<RtpCodecMessage?>? codecs;

  Object encode() {
    return <Object?>[
      transactionId,
      rtcp?.encode(),
      headerExtensions,
      encodings,
      codecs,
    ];
  }

  static RtpParametersMessage decode(Object result) {
    result as List<Object?>;
    return RtpParametersMessage(
      transactionId: result[0] as String?,
      rtcp: result[1] != null
          ? RTCParametersMessage.decode(result[1]! as List<Object?>)
          : null,
      headerExtensions: (result[2] as List<Object?>?)?.cast<HeaderExtensionMessage?>(),
      encodings: (result[3] as List<Object?>?)?.cast<RtpEncodingMessage?>(),
      codecs: (result[4] as List<Object?>?)?.cast<RtpCodecMessage?>(),
    );
  }
}

class RTCParametersMessage {
  RTCParametersMessage({
    required this.cname,
    required this.reducedSize,
  });

  String cname;

  bool reducedSize;

  Object encode() {
    return <Object?>[
      cname,
      reducedSize,
    ];
  }

  static RTCParametersMessage decode(Object result) {
    result as List<Object?>;
    return RTCParametersMessage(
      cname: result[0]! as String,
      reducedSize: result[1]! as bool,
    );
  }
}

class RtpCodecCapabilityMessage {
  RtpCodecCapabilityMessage({
    this.channels,
    required this.clockRate,
    required this.mimeType,
    this.sdpFmtpLine,
  });

  int? channels;

  int clockRate;

  String mimeType;

  String? sdpFmtpLine;

  Object encode() {
    return <Object?>[
      channels,
      clockRate,
      mimeType,
      sdpFmtpLine,
    ];
  }

  static RtpCodecCapabilityMessage decode(Object result) {
    result as List<Object?>;
    return RtpCodecCapabilityMessage(
      channels: result[0] as int?,
      clockRate: result[1]! as int,
      mimeType: result[2]! as String,
      sdpFmtpLine: result[3] as String?,
    );
  }
}

class RtpHeaderExtensionCapabilityMessage {
  RtpHeaderExtensionCapabilityMessage({
    required this.uri,
  });

  String uri;

  Object encode() {
    return <Object?>[
      uri,
    ];
  }

  static RtpHeaderExtensionCapabilityMessage decode(Object result) {
    result as List<Object?>;
    return RtpHeaderExtensionCapabilityMessage(
      uri: result[0]! as String,
    );
  }
}

class RtpCapabilitiesMessage {
  RtpCapabilitiesMessage({
    this.codecs,
    this.headerExtensions,
    this.fecMechanisms,
  });

  List<RtpCodecCapabilityMessage?>? codecs;

  List<RtpHeaderExtensionCapabilityMessage?>? headerExtensions;

  List<String?>? fecMechanisms;

  Object encode() {
    return <Object?>[
      codecs,
      headerExtensions,
      fecMechanisms,
    ];
  }

  static RtpCapabilitiesMessage decode(Object result) {
    result as List<Object?>;
    return RtpCapabilitiesMessage(
      codecs: (result[0] as List<Object?>?)?.cast<RtpCodecCapabilityMessage?>(),
      headerExtensions: (result[1] as List<Object?>?)?.cast<RtpHeaderExtensionCapabilityMessage?>(),
      fecMechanisms: (result[2] as List<Object?>?)?.cast<String?>(),
    );
  }
}

class ThumbnailSizeMessage {
  ThumbnailSizeMessage({
    required this.width,
    required this.height,
  });

  int width;

  int height;

  Object encode() {
    return <Object?>[
      width,
      height,
    ];
  }

  static ThumbnailSizeMessage decode(Object result) {
    result as List<Object?>;
    return ThumbnailSizeMessage(
      width: result[0]! as int,
      height: result[1]! as int,
    );
  }
}

class DesktopCapturerSourceMessage {
  DesktopCapturerSourceMessage({
    required this.id,
    required this.name,
    required this.type,
    required this.thumbnailSizeMessage,
  });

  String id;

  String name;

  String type;

  ThumbnailSizeMessage thumbnailSizeMessage;

  Object encode() {
    return <Object?>[
      id,
      name,
      type,
      thumbnailSizeMessage.encode(),
    ];
  }

  static DesktopCapturerSourceMessage decode(Object result) {
    result as List<Object?>;
    return DesktopCapturerSourceMessage(
      id: result[0]! as String,
      name: result[1]! as String,
      type: result[2]! as String,
      thumbnailSizeMessage: ThumbnailSizeMessage.decode(result[3]! as List<Object?>),
    );
  }
}

class _RTCPeerconnectionFactoryApiCodec extends StandardMessageCodec {
  const _RTCPeerconnectionFactoryApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is RtpCapabilitiesMessage) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is RtpCodecCapabilityMessage) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is RtpHeaderExtensionCapabilityMessage) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is dynamic) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return RtpCapabilitiesMessage.decode(readValue(buffer)!);
      case 129: 
        return RtpCodecCapabilityMessage.decode(readValue(buffer)!);
      case 130: 
        return RtpHeaderExtensionCapabilityMessage.decode(readValue(buffer)!);
      case 131: 
        return dynamic.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class RTCPeerconnectionFactoryApi {
  /// Constructor for [RTCPeerconnectionFactoryApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  RTCPeerconnectionFactoryApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _RTCPeerconnectionFactoryApiCodec();

  Future<String> createPeerconnection(Map<String?, dynamic?> arg_configuration, Map<String?, dynamic?> arg_constraints) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RTCPeerconnectionFactoryApi.createPeerconnection', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_configuration, arg_constraints]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as String?)!;
    }
  }

  Future<RtpCapabilitiesMessage> getRtpReceiverCapabilities(String arg_kind) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RTCPeerconnectionFactoryApi.getRtpReceiverCapabilities', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_kind]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as RtpCapabilitiesMessage?)!;
    }
  }

  Future<RtpCapabilitiesMessage> getRtpSenderCapabilities(String arg_kind) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RTCPeerconnectionFactoryApi.getRtpSenderCapabilities', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_kind]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as RtpCapabilitiesMessage?)!;
    }
  }
}

class _RtcPeerconnectionApiCodec extends StandardMessageCodec {
  const _RtcPeerconnectionApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is AudioTrackMessage) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is AudioTrackSettingsMessage) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is ConfigurationMessage) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is ConstraintsMessage) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else if (value is DataChannelInitMessage) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else if (value is IceCandidateMessage) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    } else if (value is MediaStreamMessage) {
      buffer.putUint8(134);
      writeValue(buffer, value.encode());
    } else if (value is SessionDescriptionMessage) {
      buffer.putUint8(135);
      writeValue(buffer, value.encode());
    } else if (value is SessionDescriptionMessage) {
      buffer.putUint8(136);
      writeValue(buffer, value.encode());
    } else if (value is StatsReportMessage) {
      buffer.putUint8(137);
      writeValue(buffer, value.encode());
    } else if (value is VideoTrackMessage) {
      buffer.putUint8(138);
      writeValue(buffer, value.encode());
    } else if (value is VideoTrackSettingsMessage) {
      buffer.putUint8(139);
      writeValue(buffer, value.encode());
    } else if (value is dynamic) {
      buffer.putUint8(140);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return AudioTrackMessage.decode(readValue(buffer)!);
      case 129: 
        return AudioTrackSettingsMessage.decode(readValue(buffer)!);
      case 130: 
        return ConfigurationMessage.decode(readValue(buffer)!);
      case 131: 
        return ConstraintsMessage.decode(readValue(buffer)!);
      case 132: 
        return DataChannelInitMessage.decode(readValue(buffer)!);
      case 133: 
        return IceCandidateMessage.decode(readValue(buffer)!);
      case 134: 
        return MediaStreamMessage.decode(readValue(buffer)!);
      case 135: 
        return SessionDescriptionMessage.decode(readValue(buffer)!);
      case 136: 
        return SessionDescriptionMessage.decode(readValue(buffer)!);
      case 137: 
        return StatsReportMessage.decode(readValue(buffer)!);
      case 138: 
        return VideoTrackMessage.decode(readValue(buffer)!);
      case 139: 
        return VideoTrackSettingsMessage.decode(readValue(buffer)!);
      case 140: 
        return dynamic.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class RtcPeerconnectionApi {
  /// Constructor for [RtcPeerconnectionApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  RtcPeerconnectionApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _RtcPeerconnectionApiCodec();

  Future<void> addCandidate(String arg_peerconnectionId, IceCandidateMessage arg_msg) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RtcPeerconnectionApi.addCandidate', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_peerconnectionId, arg_msg]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> addStream(String arg_peerconnectionId, String arg_streamId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RtcPeerconnectionApi.addStream', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_peerconnectionId, arg_streamId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<Map<String?, dynamic?>> addTrack(String arg_peerconnectionId, String arg_trackId, List<String?>? arg_streamIds) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RtcPeerconnectionApi.addTrack', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_peerconnectionId, arg_trackId, arg_streamIds]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as Map<Object?, Object?>?)!.cast<String?, dynamic?>();
    }
  }

  Future<void> close(String arg_peerconnectionId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RtcPeerconnectionApi.close', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_peerconnectionId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<SessionDescriptionMessage> createAnswer(String arg_peerconnectionId, ConstraintsMessage arg_msg) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RtcPeerconnectionApi.createAnswer', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_peerconnectionId, arg_msg]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as SessionDescriptionMessage?)!;
    }
  }

  Future<Map<String?, dynamic?>> createDataChannel(String arg_peerconnectionId, String arg_label, DataChannelInitMessage arg_msg) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RtcPeerconnectionApi.createDataChannel', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_peerconnectionId, arg_label, arg_msg]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as Map<Object?, Object?>?)!.cast<String?, dynamic?>();
    }
  }

  Future<SessionDescriptionMessage> createOffer(String arg_peerconnectionId, ConstraintsMessage arg_msg) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RtcPeerconnectionApi.createOffer', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_peerconnectionId, arg_msg]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as SessionDescriptionMessage?)!;
    }
  }

  Future<void> dispose(String arg_peerconnectionId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RtcPeerconnectionApi.dispose', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_peerconnectionId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<SessionDescriptionMessage?> getLocalDescription(String arg_peerconnectionId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RtcPeerconnectionApi.getLocalDescription', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_peerconnectionId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return (replyList[0] as SessionDescriptionMessage?);
    }
  }

  Future<List<MediaStreamMessage?>> getLocalStreams(String arg_peerconnectionId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RtcPeerconnectionApi.getLocalStreams', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_peerconnectionId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as List<Object?>?)!.cast<MediaStreamMessage?>();
    }
  }

  Future<List<MediaStreamMessage?>> getRemoteStreams(String arg_peerconnectionId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RtcPeerconnectionApi.getRemoteStreams', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_peerconnectionId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as List<Object?>?)!.cast<MediaStreamMessage?>();
    }
  }

  Future<List<Map<String?, dynamic?>?>> getReceivers(String arg_peerconnectionId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RtcPeerconnectionApi.getReceivers', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_peerconnectionId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as List<Object?>?)!.cast<Map<String?, dynamic?>?>();
    }
  }

  Future<List<Map<String?, dynamic?>?>> getSenders(String arg_peerconnectionId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RtcPeerconnectionApi.getSenders', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_peerconnectionId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as List<Object?>?)!.cast<Map<String?, dynamic?>?>();
    }
  }

  Future<List<Map<String?, dynamic?>?>> getTransceivers(String arg_peerconnectionId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RtcPeerconnectionApi.getTransceivers', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_peerconnectionId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as List<Object?>?)!.cast<Map<String?, dynamic?>?>();
    }
  }

  Future<List<StatsReportMessage?>> getStats(String arg_peerconnectionId, String arg_trackId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RtcPeerconnectionApi.getStats', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_peerconnectionId, arg_trackId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as List<Object?>?)!.cast<StatsReportMessage?>();
    }
  }

  Future<void> removeStream(String arg_peerconnectionId, String arg_streamId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RtcPeerconnectionApi.removeStream', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_peerconnectionId, arg_streamId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<bool> removeTrack(String arg_peerconnectionId, String arg_senderId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RtcPeerconnectionApi.removeTrack', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_peerconnectionId, arg_senderId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as bool?)!;
    }
  }

  Future<void> restartIce(String arg_peerconnectionId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RtcPeerconnectionApi.restartIce', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_peerconnectionId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> setConfiguration(String arg_peerconnectionId, ConfigurationMessage arg_msg) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RtcPeerconnectionApi.setConfiguration', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_peerconnectionId, arg_msg]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> setLocalDescription(String arg_peerconnectionId, SessionDescriptionMessage arg_msg) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RtcPeerconnectionApi.setLocalDescription', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_peerconnectionId, arg_msg]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<SessionDescriptionMessage> getRemoteDescription(String arg_peerconnectionId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RtcPeerconnectionApi.getRemoteDescription', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_peerconnectionId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as SessionDescriptionMessage?)!;
    }
  }

  Future<void> setRemoteDescription(String arg_peerconnectionId, SessionDescriptionMessage arg_msg) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RtcPeerconnectionApi.setRemoteDescription', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_peerconnectionId, arg_msg]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }
}

class _RTCDataChannelApiCodec extends StandardMessageCodec {
  const _RTCDataChannelApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is DataChannelMessage) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return DataChannelMessage.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class RTCDataChannelApi {
  /// Constructor for [RTCDataChannelApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  RTCDataChannelApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _RTCDataChannelApiCodec();

  Future<void> send(String arg_peerconnectionId, DataChannelMessage arg_message) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RTCDataChannelApi.send', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_peerconnectionId, arg_message]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> close(String arg_peerconnectionId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RTCDataChannelApi.close', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_peerconnectionId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }
}

class RTCDTMFSenderApi {
  /// Constructor for [RTCDTMFSenderApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  RTCDTMFSenderApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = StandardMessageCodec();

  Future<void> insertDtmf(String arg_peerconnectionId, String arg_rtpSenderId, String arg_tones, int arg_duration, int arg_interToneGap) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RTCDTMFSenderApi.insertDtmf', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_peerconnectionId, arg_rtpSenderId, arg_tones, arg_duration, arg_interToneGap]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<bool> canInsertDtmf(String arg_peerconnectionId, String arg_rtpSenderId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RTCDTMFSenderApi.canInsertDtmf', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_peerconnectionId, arg_rtpSenderId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as bool?)!;
    }
  }
}

class _RTCRtpSenderApiCodec extends StandardMessageCodec {
  const _RTCRtpSenderApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is HeaderExtensionMessage) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is RTCParametersMessage) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is RtpCodecMessage) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is RtpEncodingMessage) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else if (value is RtpParametersMessage) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else if (value is dynamic) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return HeaderExtensionMessage.decode(readValue(buffer)!);
      case 129: 
        return RTCParametersMessage.decode(readValue(buffer)!);
      case 130: 
        return RtpCodecMessage.decode(readValue(buffer)!);
      case 131: 
        return RtpEncodingMessage.decode(readValue(buffer)!);
      case 132: 
        return RtpParametersMessage.decode(readValue(buffer)!);
      case 133: 
        return dynamic.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class RTCRtpSenderApi {
  /// Constructor for [RTCRtpSenderApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  RTCRtpSenderApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _RTCRtpSenderApiCodec();

  Future<bool> setParameters(String arg_peerconnectionId, String arg_rtpSenderId, RtpParametersMessage arg_parameters) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RTCRtpSenderApi.setParameters', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_peerconnectionId, arg_rtpSenderId, arg_parameters]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as bool?)!;
    }
  }

  Future<void> replaceTrack(String arg_peerconnectionId, String arg_rtpSenderId, String arg_trackId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RTCRtpSenderApi.replaceTrack', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_peerconnectionId, arg_rtpSenderId, arg_trackId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> setTrack(String arg_peerconnectionId, String arg_rtpSenderId, String arg_trackId, bool arg_takeOwnership) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RTCRtpSenderApi.setTrack', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_peerconnectionId, arg_rtpSenderId, arg_trackId, arg_takeOwnership]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }
}

class _RTCRtpTransceiverApiCodec extends StandardMessageCodec {
  const _RTCRtpTransceiverApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is RtpCodecCapabilityMessage) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return RtpCodecCapabilityMessage.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class RTCRtpTransceiverApi {
  /// Constructor for [RTCRtpTransceiverApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  RTCRtpTransceiverApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _RTCRtpTransceiverApiCodec();

  Future<void> setDirection(String arg_peerconnectionId, String arg_transceiverId, String arg_direction) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RTCRtpTransceiverApi.setDirection', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_peerconnectionId, arg_transceiverId, arg_direction]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<String?> getCurrentDirection(String arg_peerconnectionId, String arg_transceiverId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RTCRtpTransceiverApi.getCurrentDirection', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_peerconnectionId, arg_transceiverId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return (replyList[0] as String?);
    }
  }

  Future<String> getDirection(String arg_peerconnectionId, String arg_transceiverId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RTCRtpTransceiverApi.getDirection', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_peerconnectionId, arg_transceiverId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as String?)!;
    }
  }

  Future<void> stop(String arg_peerconnectionId, String arg_transceiverId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RTCRtpTransceiverApi.stop', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_peerconnectionId, arg_transceiverId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> setCodecPreferences(String arg_peerconnectionId, String arg_transceiverId, List<RtpCodecCapabilityMessage?> arg_codecs) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RTCRtpTransceiverApi.setCodecPreferences', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_peerconnectionId, arg_transceiverId, arg_codecs]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }
}

class RTCVideoRendererApi {
  /// Constructor for [RTCVideoRendererApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  RTCVideoRendererApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = StandardMessageCodec();

  Future<int?> initialize() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RTCVideoRendererApi.initialize', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return (replyList[0] as int?);
    }
  }

  Future<void> setSrcObject(int arg_textureId, String arg_streamId, String arg_ownerTag, String? arg_trackId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RTCVideoRendererApi.setSrcObject', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_textureId, arg_streamId, arg_ownerTag, arg_trackId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> dispose(int arg_textureId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RTCVideoRendererApi.dispose', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_textureId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }
}

class MediaRecorderApi {
  /// Constructor for [MediaRecorderApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  MediaRecorderApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = StandardMessageCodec();

  Future<void> start(String arg_path, int arg_audioChannel, String? arg_videoTrackId, int arg_recorderId, String? arg_peerconnectionId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MediaRecorderApi.start', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_path, arg_audioChannel, arg_videoTrackId, arg_recorderId, arg_peerconnectionId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> stop(int arg_recorderId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MediaRecorderApi.stop', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_recorderId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }
}

class MediaStreamApi {
  /// Constructor for [MediaStreamApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  MediaStreamApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = StandardMessageCodec();

  Future<void> getMediaTracks(String arg_streamId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MediaStreamApi.getMediaTracks', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_streamId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> addTrack(String arg_streamId, String arg_trackId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MediaStreamApi.addTrack', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_streamId, arg_trackId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> removeTrack(String arg_streamId, String arg_trackId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MediaStreamApi.removeTrack', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_streamId, arg_trackId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> dispose(String arg_streamId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MediaStreamApi.dispose', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_streamId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }
}

class MediaStreamTrackApi {
  /// Constructor for [MediaStreamTrackApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  MediaStreamTrackApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = StandardMessageCodec();

  Future<void> enable(String arg_trackId, bool arg_enabled, String arg_peerconnectionId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MediaStreamTrackApi.enable', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_trackId, arg_enabled, arg_peerconnectionId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<bool> hasTorch(String arg_trackId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MediaStreamTrackApi.hasTorch', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_trackId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as bool?)!;
    }
  }

  Future<void> setTorch(String arg_trackId, bool arg_torch) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MediaStreamTrackApi.setTorch', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_trackId, arg_torch]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> captureFrame(String arg_trackId, String arg_peerconnectionId, String arg_path) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MediaStreamTrackApi.captureFrame', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_trackId, arg_peerconnectionId, arg_path]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> stop(String arg_trackId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MediaStreamTrackApi.stop', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_trackId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }
}

class _DesktopCapturerSourceApiCodec extends StandardMessageCodec {
  const _DesktopCapturerSourceApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is DesktopCapturerSourceMessage) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is ThumbnailSizeMessage) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return DesktopCapturerSourceMessage.decode(readValue(buffer)!);
      case 129: 
        return ThumbnailSizeMessage.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class DesktopCapturerSourceApi {
  /// Constructor for [DesktopCapturerSourceApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  DesktopCapturerSourceApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _DesktopCapturerSourceApiCodec();

  Future<List<DesktopCapturerSourceMessage?>> getDesktopSources(List<String?> arg_types, ThumbnailSizeMessage arg_thumbnailSize) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.DesktopCapturerSourceApi.getDesktopSources', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_types, arg_thumbnailSize]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as List<Object?>?)!.cast<DesktopCapturerSourceMessage?>();
    }
  }

  Future<bool> updateSources(List<String?> arg_types) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.DesktopCapturerSourceApi.updateSources', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_types]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as bool?)!;
    }
  }

  Future<Uint8List?> getThumbnail(String arg_sourceId, ThumbnailSizeMessage arg_thumbnailSize) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.DesktopCapturerSourceApi.getThumbnail', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_sourceId, arg_thumbnailSize]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return (replyList[0] as Uint8List?);
    }
  }
}

class _MediaDevicesCodec extends StandardMessageCodec {
  const _MediaDevicesCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is AudioTrackMessage) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is AudioTrackSettingsMessage) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is MediaDeviceInfoMessage) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is MediaStreamMessage) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else if (value is VideoTrackMessage) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else if (value is VideoTrackSettingsMessage) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    } else if (value is dynamic) {
      buffer.putUint8(134);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return AudioTrackMessage.decode(readValue(buffer)!);
      case 129: 
        return AudioTrackSettingsMessage.decode(readValue(buffer)!);
      case 130: 
        return MediaDeviceInfoMessage.decode(readValue(buffer)!);
      case 131: 
        return MediaStreamMessage.decode(readValue(buffer)!);
      case 132: 
        return VideoTrackMessage.decode(readValue(buffer)!);
      case 133: 
        return VideoTrackSettingsMessage.decode(readValue(buffer)!);
      case 134: 
        return dynamic.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class MediaDevices {
  /// Constructor for [MediaDevices].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  MediaDevices({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _MediaDevicesCodec();

  Future<MediaStreamMessage> getUserMedia(Map<String?, dynamic?> arg_mediaConstraints) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MediaDevices.getUserMedia', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_mediaConstraints]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as MediaStreamMessage?)!;
    }
  }

  Future<MediaStreamMessage> getDisplayMedia(Map<String?, dynamic?> arg_mediaConstraints) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MediaDevices.getDisplayMedia', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_mediaConstraints]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as MediaStreamMessage?)!;
    }
  }

  Future<List<dynamic?>> getSources() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MediaDevices.getSources', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as List<Object?>?)!.cast<dynamic?>();
    }
  }

  Future<List<MediaDeviceInfoMessage?>> enumerateDevices() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MediaDevices.enumerateDevices', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as List<Object?>?)!.cast<MediaDeviceInfoMessage?>();
    }
  }

  Future<MediaDeviceInfoMessage> selectAudioOutput(String arg_deviceId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.MediaDevices.selectAudioOutput', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_deviceId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as MediaDeviceInfoMessage?)!;
    }
  }
}
