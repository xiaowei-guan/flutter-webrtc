// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v9.2.4), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#undef _HAS_EXCEPTIONS

#include "messages.h"

#include <flutter/basic_message_channel.h>
#include <flutter/binary_messenger.h>
#include <flutter/encodable_value.h>
#include <flutter/standard_message_codec.h>

#include <map>
#include <optional>
#include <string>

namespace flutter_webrtc_plugin {
using flutter::BasicMessageChannel;
using flutter::CustomEncodableValue;
using flutter::EncodableList;
using flutter::EncodableMap;
using flutter::EncodableValue;

// SessionDescriptionMessage

SessionDescriptionMessage::SessionDescriptionMessage() {}

SessionDescriptionMessage::SessionDescriptionMessage(
  const std::string* sdp,
  const std::string* type)
 : sdp_(sdp ? std::optional<std::string>(*sdp) : std::nullopt),
    type_(type ? std::optional<std::string>(*type) : std::nullopt) {}

const std::string* SessionDescriptionMessage::sdp() const {
  return sdp_ ? &(*sdp_) : nullptr;
}

void SessionDescriptionMessage::set_sdp(const std::string_view* value_arg) {
  sdp_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void SessionDescriptionMessage::set_sdp(std::string_view value_arg) {
  sdp_ = value_arg;
}


const std::string* SessionDescriptionMessage::type() const {
  return type_ ? &(*type_) : nullptr;
}

void SessionDescriptionMessage::set_type(const std::string_view* value_arg) {
  type_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void SessionDescriptionMessage::set_type(std::string_view value_arg) {
  type_ = value_arg;
}


EncodableList SessionDescriptionMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(2);
  list.push_back(sdp_ ? EncodableValue(*sdp_) : EncodableValue());
  list.push_back(type_ ? EncodableValue(*type_) : EncodableValue());
  return list;
}

SessionDescriptionMessage SessionDescriptionMessage::FromEncodableList(const EncodableList& list) {
  SessionDescriptionMessage decoded;
  auto& encodable_sdp = list[0];
  if (!encodable_sdp.IsNull()) {
    decoded.set_sdp(std::get<std::string>(encodable_sdp));
  }
  auto& encodable_type = list[1];
  if (!encodable_type.IsNull()) {
    decoded.set_type(std::get<std::string>(encodable_type));
  }
  return decoded;
}

// ConstraintsMessage

ConstraintsMessage::ConstraintsMessage(const EncodableMap& constraints)
 : constraints_(constraints) {}

const EncodableMap& ConstraintsMessage::constraints() const {
  return constraints_;
}

void ConstraintsMessage::set_constraints(const EncodableMap& value_arg) {
  constraints_ = value_arg;
}


EncodableList ConstraintsMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(1);
  list.push_back(EncodableValue(constraints_));
  return list;
}

ConstraintsMessage ConstraintsMessage::FromEncodableList(const EncodableList& list) {
  ConstraintsMessage decoded(
    std::get<EncodableMap>(list[0]));
  return decoded;
}

// ConfigurationMessage

ConfigurationMessage::ConfigurationMessage(const EncodableMap& configurations)
 : configurations_(configurations) {}

const EncodableMap& ConfigurationMessage::configurations() const {
  return configurations_;
}

void ConfigurationMessage::set_configurations(const EncodableMap& value_arg) {
  configurations_ = value_arg;
}


EncodableList ConfigurationMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(1);
  list.push_back(EncodableValue(configurations_));
  return list;
}

ConfigurationMessage ConfigurationMessage::FromEncodableList(const EncodableList& list) {
  ConfigurationMessage decoded(
    std::get<EncodableMap>(list[0]));
  return decoded;
}

// AudioTrackSettingsMessage

AudioTrackSettingsMessage::AudioTrackSettingsMessage(
  const std::string& device_id,
  const std::string& kind,
  bool auto_gain_control,
  bool echo_cancellation,
  bool noise_suppression,
  int64_t channel_count,
  int64_t latency)
 : device_id_(device_id),
    kind_(kind),
    auto_gain_control_(auto_gain_control),
    echo_cancellation_(echo_cancellation),
    noise_suppression_(noise_suppression),
    channel_count_(channel_count),
    latency_(latency) {}

const std::string& AudioTrackSettingsMessage::device_id() const {
  return device_id_;
}

void AudioTrackSettingsMessage::set_device_id(std::string_view value_arg) {
  device_id_ = value_arg;
}


const std::string& AudioTrackSettingsMessage::kind() const {
  return kind_;
}

void AudioTrackSettingsMessage::set_kind(std::string_view value_arg) {
  kind_ = value_arg;
}


bool AudioTrackSettingsMessage::auto_gain_control() const {
  return auto_gain_control_;
}

void AudioTrackSettingsMessage::set_auto_gain_control(bool value_arg) {
  auto_gain_control_ = value_arg;
}


bool AudioTrackSettingsMessage::echo_cancellation() const {
  return echo_cancellation_;
}

void AudioTrackSettingsMessage::set_echo_cancellation(bool value_arg) {
  echo_cancellation_ = value_arg;
}


bool AudioTrackSettingsMessage::noise_suppression() const {
  return noise_suppression_;
}

void AudioTrackSettingsMessage::set_noise_suppression(bool value_arg) {
  noise_suppression_ = value_arg;
}


int64_t AudioTrackSettingsMessage::channel_count() const {
  return channel_count_;
}

void AudioTrackSettingsMessage::set_channel_count(int64_t value_arg) {
  channel_count_ = value_arg;
}


int64_t AudioTrackSettingsMessage::latency() const {
  return latency_;
}

void AudioTrackSettingsMessage::set_latency(int64_t value_arg) {
  latency_ = value_arg;
}


EncodableList AudioTrackSettingsMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(7);
  list.push_back(EncodableValue(device_id_));
  list.push_back(EncodableValue(kind_));
  list.push_back(EncodableValue(auto_gain_control_));
  list.push_back(EncodableValue(echo_cancellation_));
  list.push_back(EncodableValue(noise_suppression_));
  list.push_back(EncodableValue(channel_count_));
  list.push_back(EncodableValue(latency_));
  return list;
}

AudioTrackSettingsMessage AudioTrackSettingsMessage::FromEncodableList(const EncodableList& list) {
  AudioTrackSettingsMessage decoded(
    std::get<std::string>(list[0]),
    std::get<std::string>(list[1]),
    std::get<bool>(list[2]),
    std::get<bool>(list[3]),
    std::get<bool>(list[4]),
    list[5].LongValue(),
    list[6].LongValue());
  return decoded;
}

// AudioTrackMessage

AudioTrackMessage::AudioTrackMessage(
  const std::string& id,
  const std::string& label,
  const std::string& kind,
  bool enabled,
  const AudioTrackSettingsMessage& settings)
 : id_(id),
    label_(label),
    kind_(kind),
    enabled_(enabled),
    settings_(settings) {}

const std::string& AudioTrackMessage::id() const {
  return id_;
}

void AudioTrackMessage::set_id(std::string_view value_arg) {
  id_ = value_arg;
}


const std::string& AudioTrackMessage::label() const {
  return label_;
}

void AudioTrackMessage::set_label(std::string_view value_arg) {
  label_ = value_arg;
}


const std::string& AudioTrackMessage::kind() const {
  return kind_;
}

void AudioTrackMessage::set_kind(std::string_view value_arg) {
  kind_ = value_arg;
}


bool AudioTrackMessage::enabled() const {
  return enabled_;
}

void AudioTrackMessage::set_enabled(bool value_arg) {
  enabled_ = value_arg;
}


const AudioTrackSettingsMessage& AudioTrackMessage::settings() const {
  return settings_;
}

void AudioTrackMessage::set_settings(const AudioTrackSettingsMessage& value_arg) {
  settings_ = value_arg;
}


EncodableList AudioTrackMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(5);
  list.push_back(EncodableValue(id_));
  list.push_back(EncodableValue(label_));
  list.push_back(EncodableValue(kind_));
  list.push_back(EncodableValue(enabled_));
  list.push_back(EncodableValue(settings_.ToEncodableList()));
  return list;
}

AudioTrackMessage AudioTrackMessage::FromEncodableList(const EncodableList& list) {
  AudioTrackMessage decoded(
    std::get<std::string>(list[0]),
    std::get<std::string>(list[1]),
    std::get<std::string>(list[2]),
    std::get<bool>(list[3]),
    AudioTrackSettingsMessage::FromEncodableList(std::get<EncodableList>(list[4])));
  return decoded;
}

// VideoTrackSettingsMessage

VideoTrackSettingsMessage::VideoTrackSettingsMessage(
  const std::string& device_id,
  const std::string& kind,
  int64_t width,
  int64_t height,
  int64_t frame_rate)
 : device_id_(device_id),
    kind_(kind),
    width_(width),
    height_(height),
    frame_rate_(frame_rate) {}

const std::string& VideoTrackSettingsMessage::device_id() const {
  return device_id_;
}

void VideoTrackSettingsMessage::set_device_id(std::string_view value_arg) {
  device_id_ = value_arg;
}


const std::string& VideoTrackSettingsMessage::kind() const {
  return kind_;
}

void VideoTrackSettingsMessage::set_kind(std::string_view value_arg) {
  kind_ = value_arg;
}


int64_t VideoTrackSettingsMessage::width() const {
  return width_;
}

void VideoTrackSettingsMessage::set_width(int64_t value_arg) {
  width_ = value_arg;
}


int64_t VideoTrackSettingsMessage::height() const {
  return height_;
}

void VideoTrackSettingsMessage::set_height(int64_t value_arg) {
  height_ = value_arg;
}


int64_t VideoTrackSettingsMessage::frame_rate() const {
  return frame_rate_;
}

void VideoTrackSettingsMessage::set_frame_rate(int64_t value_arg) {
  frame_rate_ = value_arg;
}


EncodableList VideoTrackSettingsMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(5);
  list.push_back(EncodableValue(device_id_));
  list.push_back(EncodableValue(kind_));
  list.push_back(EncodableValue(width_));
  list.push_back(EncodableValue(height_));
  list.push_back(EncodableValue(frame_rate_));
  return list;
}

VideoTrackSettingsMessage VideoTrackSettingsMessage::FromEncodableList(const EncodableList& list) {
  VideoTrackSettingsMessage decoded(
    std::get<std::string>(list[0]),
    std::get<std::string>(list[1]),
    list[2].LongValue(),
    list[3].LongValue(),
    list[4].LongValue());
  return decoded;
}

// VideoTrackMessage

VideoTrackMessage::VideoTrackMessage(
  const std::string& id,
  const std::string& label,
  const std::string& kind,
  bool enabled,
  const VideoTrackSettingsMessage& settings)
 : id_(id),
    label_(label),
    kind_(kind),
    enabled_(enabled),
    settings_(settings) {}

const std::string& VideoTrackMessage::id() const {
  return id_;
}

void VideoTrackMessage::set_id(std::string_view value_arg) {
  id_ = value_arg;
}


const std::string& VideoTrackMessage::label() const {
  return label_;
}

void VideoTrackMessage::set_label(std::string_view value_arg) {
  label_ = value_arg;
}


const std::string& VideoTrackMessage::kind() const {
  return kind_;
}

void VideoTrackMessage::set_kind(std::string_view value_arg) {
  kind_ = value_arg;
}


bool VideoTrackMessage::enabled() const {
  return enabled_;
}

void VideoTrackMessage::set_enabled(bool value_arg) {
  enabled_ = value_arg;
}


const VideoTrackSettingsMessage& VideoTrackMessage::settings() const {
  return settings_;
}

void VideoTrackMessage::set_settings(const VideoTrackSettingsMessage& value_arg) {
  settings_ = value_arg;
}


EncodableList VideoTrackMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(5);
  list.push_back(EncodableValue(id_));
  list.push_back(EncodableValue(label_));
  list.push_back(EncodableValue(kind_));
  list.push_back(EncodableValue(enabled_));
  list.push_back(EncodableValue(settings_.ToEncodableList()));
  return list;
}

VideoTrackMessage VideoTrackMessage::FromEncodableList(const EncodableList& list) {
  VideoTrackMessage decoded(
    std::get<std::string>(list[0]),
    std::get<std::string>(list[1]),
    std::get<std::string>(list[2]),
    std::get<bool>(list[3]),
    VideoTrackSettingsMessage::FromEncodableList(std::get<EncodableList>(list[4])));
  return decoded;
}

// MediaStreamMessage

MediaStreamMessage::MediaStreamMessage(
  const std::string& id,
  const std::string& owner_tag,
  const EncodableList& audio_tracks,
  const EncodableList& video_tracks)
 : id_(id),
    owner_tag_(owner_tag),
    audio_tracks_(audio_tracks),
    video_tracks_(video_tracks) {}

const std::string& MediaStreamMessage::id() const {
  return id_;
}

void MediaStreamMessage::set_id(std::string_view value_arg) {
  id_ = value_arg;
}


const std::string& MediaStreamMessage::owner_tag() const {
  return owner_tag_;
}

void MediaStreamMessage::set_owner_tag(std::string_view value_arg) {
  owner_tag_ = value_arg;
}


const EncodableList& MediaStreamMessage::audio_tracks() const {
  return audio_tracks_;
}

void MediaStreamMessage::set_audio_tracks(const EncodableList& value_arg) {
  audio_tracks_ = value_arg;
}


const EncodableList& MediaStreamMessage::video_tracks() const {
  return video_tracks_;
}

void MediaStreamMessage::set_video_tracks(const EncodableList& value_arg) {
  video_tracks_ = value_arg;
}


EncodableList MediaStreamMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(4);
  list.push_back(EncodableValue(id_));
  list.push_back(EncodableValue(owner_tag_));
  list.push_back(EncodableValue(audio_tracks_));
  list.push_back(EncodableValue(video_tracks_));
  return list;
}

MediaStreamMessage MediaStreamMessage::FromEncodableList(const EncodableList& list) {
  MediaStreamMessage decoded(
    std::get<std::string>(list[0]),
    std::get<std::string>(list[1]),
    std::get<EncodableList>(list[2]),
    std::get<EncodableList>(list[3]));
  return decoded;
}

// MediaDeviceInfoMessage

MediaDeviceInfoMessage::MediaDeviceInfoMessage(
  const std::string& device_id,
  const std::string& label)
 : device_id_(device_id),
    label_(label) {}

MediaDeviceInfoMessage::MediaDeviceInfoMessage(
  const std::string& device_id,
  const std::string* group_id,
  const std::string* kind,
  const std::string& label)
 : device_id_(device_id),
    group_id_(group_id ? std::optional<std::string>(*group_id) : std::nullopt),
    kind_(kind ? std::optional<std::string>(*kind) : std::nullopt),
    label_(label) {}

const std::string& MediaDeviceInfoMessage::device_id() const {
  return device_id_;
}

void MediaDeviceInfoMessage::set_device_id(std::string_view value_arg) {
  device_id_ = value_arg;
}


const std::string* MediaDeviceInfoMessage::group_id() const {
  return group_id_ ? &(*group_id_) : nullptr;
}

void MediaDeviceInfoMessage::set_group_id(const std::string_view* value_arg) {
  group_id_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void MediaDeviceInfoMessage::set_group_id(std::string_view value_arg) {
  group_id_ = value_arg;
}


const std::string* MediaDeviceInfoMessage::kind() const {
  return kind_ ? &(*kind_) : nullptr;
}

void MediaDeviceInfoMessage::set_kind(const std::string_view* value_arg) {
  kind_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void MediaDeviceInfoMessage::set_kind(std::string_view value_arg) {
  kind_ = value_arg;
}


const std::string& MediaDeviceInfoMessage::label() const {
  return label_;
}

void MediaDeviceInfoMessage::set_label(std::string_view value_arg) {
  label_ = value_arg;
}


EncodableList MediaDeviceInfoMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(4);
  list.push_back(EncodableValue(device_id_));
  list.push_back(group_id_ ? EncodableValue(*group_id_) : EncodableValue());
  list.push_back(kind_ ? EncodableValue(*kind_) : EncodableValue());
  list.push_back(EncodableValue(label_));
  return list;
}

MediaDeviceInfoMessage MediaDeviceInfoMessage::FromEncodableList(const EncodableList& list) {
  MediaDeviceInfoMessage decoded(
    std::get<std::string>(list[0]),
    std::get<std::string>(list[3]));
  auto& encodable_group_id = list[1];
  if (!encodable_group_id.IsNull()) {
    decoded.set_group_id(std::get<std::string>(encodable_group_id));
  }
  auto& encodable_kind = list[2];
  if (!encodable_kind.IsNull()) {
    decoded.set_kind(std::get<std::string>(encodable_kind));
  }
  return decoded;
}

// IceCandidateMessage

IceCandidateMessage::IceCandidateMessage() {}

IceCandidateMessage::IceCandidateMessage(
  const std::string* candidate,
  const std::string* sdp_mid,
  const int64_t* sdp_m_line_index)
 : candidate_(candidate ? std::optional<std::string>(*candidate) : std::nullopt),
    sdp_mid_(sdp_mid ? std::optional<std::string>(*sdp_mid) : std::nullopt),
    sdp_m_line_index_(sdp_m_line_index ? std::optional<int64_t>(*sdp_m_line_index) : std::nullopt) {}

const std::string* IceCandidateMessage::candidate() const {
  return candidate_ ? &(*candidate_) : nullptr;
}

void IceCandidateMessage::set_candidate(const std::string_view* value_arg) {
  candidate_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void IceCandidateMessage::set_candidate(std::string_view value_arg) {
  candidate_ = value_arg;
}


const std::string* IceCandidateMessage::sdp_mid() const {
  return sdp_mid_ ? &(*sdp_mid_) : nullptr;
}

void IceCandidateMessage::set_sdp_mid(const std::string_view* value_arg) {
  sdp_mid_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void IceCandidateMessage::set_sdp_mid(std::string_view value_arg) {
  sdp_mid_ = value_arg;
}


const int64_t* IceCandidateMessage::sdp_m_line_index() const {
  return sdp_m_line_index_ ? &(*sdp_m_line_index_) : nullptr;
}

void IceCandidateMessage::set_sdp_m_line_index(const int64_t* value_arg) {
  sdp_m_line_index_ = value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void IceCandidateMessage::set_sdp_m_line_index(int64_t value_arg) {
  sdp_m_line_index_ = value_arg;
}


EncodableList IceCandidateMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(3);
  list.push_back(candidate_ ? EncodableValue(*candidate_) : EncodableValue());
  list.push_back(sdp_mid_ ? EncodableValue(*sdp_mid_) : EncodableValue());
  list.push_back(sdp_m_line_index_ ? EncodableValue(*sdp_m_line_index_) : EncodableValue());
  return list;
}

IceCandidateMessage IceCandidateMessage::FromEncodableList(const EncodableList& list) {
  IceCandidateMessage decoded;
  auto& encodable_candidate = list[0];
  if (!encodable_candidate.IsNull()) {
    decoded.set_candidate(std::get<std::string>(encodable_candidate));
  }
  auto& encodable_sdp_mid = list[1];
  if (!encodable_sdp_mid.IsNull()) {
    decoded.set_sdp_mid(std::get<std::string>(encodable_sdp_mid));
  }
  auto& encodable_sdp_m_line_index = list[2];
  if (!encodable_sdp_m_line_index.IsNull()) {
    decoded.set_sdp_m_line_index(encodable_sdp_m_line_index.LongValue());
  }
  return decoded;
}

// StatsReportMessage

StatsReportMessage::StatsReportMessage(const EncodableMap& values)
 : values_(values) {}

StatsReportMessage::StatsReportMessage(
  const std::string* id,
  const std::string* type,
  const double* timestamp,
  const EncodableMap& values)
 : id_(id ? std::optional<std::string>(*id) : std::nullopt),
    type_(type ? std::optional<std::string>(*type) : std::nullopt),
    timestamp_(timestamp ? std::optional<double>(*timestamp) : std::nullopt),
    values_(values) {}

const std::string* StatsReportMessage::id() const {
  return id_ ? &(*id_) : nullptr;
}

void StatsReportMessage::set_id(const std::string_view* value_arg) {
  id_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void StatsReportMessage::set_id(std::string_view value_arg) {
  id_ = value_arg;
}


const std::string* StatsReportMessage::type() const {
  return type_ ? &(*type_) : nullptr;
}

void StatsReportMessage::set_type(const std::string_view* value_arg) {
  type_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void StatsReportMessage::set_type(std::string_view value_arg) {
  type_ = value_arg;
}


const double* StatsReportMessage::timestamp() const {
  return timestamp_ ? &(*timestamp_) : nullptr;
}

void StatsReportMessage::set_timestamp(const double* value_arg) {
  timestamp_ = value_arg ? std::optional<double>(*value_arg) : std::nullopt;
}

void StatsReportMessage::set_timestamp(double value_arg) {
  timestamp_ = value_arg;
}


const EncodableMap& StatsReportMessage::values() const {
  return values_;
}

void StatsReportMessage::set_values(const EncodableMap& value_arg) {
  values_ = value_arg;
}


EncodableList StatsReportMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(4);
  list.push_back(id_ ? EncodableValue(*id_) : EncodableValue());
  list.push_back(type_ ? EncodableValue(*type_) : EncodableValue());
  list.push_back(timestamp_ ? EncodableValue(*timestamp_) : EncodableValue());
  list.push_back(EncodableValue(values_));
  return list;
}

StatsReportMessage StatsReportMessage::FromEncodableList(const EncodableList& list) {
  StatsReportMessage decoded(
    std::get<EncodableMap>(list[3]));
  auto& encodable_id = list[0];
  if (!encodable_id.IsNull()) {
    decoded.set_id(std::get<std::string>(encodable_id));
  }
  auto& encodable_type = list[1];
  if (!encodable_type.IsNull()) {
    decoded.set_type(std::get<std::string>(encodable_type));
  }
  auto& encodable_timestamp = list[2];
  if (!encodable_timestamp.IsNull()) {
    decoded.set_timestamp(std::get<double>(encodable_timestamp));
  }
  return decoded;
}

// DataChannelMessage

DataChannelMessage::DataChannelMessage(
  const std::string& channel_id,
  const std::string& type)
 : channel_id_(channel_id),
    type_(type) {}

DataChannelMessage::DataChannelMessage(
  const std::string& channel_id,
  const std::string& type,
  const std::vector<uint8_t>* binary,
  const std::string* text)
 : channel_id_(channel_id),
    type_(type),
    binary_(binary ? std::optional<std::vector<uint8_t>>(*binary) : std::nullopt),
    text_(text ? std::optional<std::string>(*text) : std::nullopt) {}

const std::string& DataChannelMessage::channel_id() const {
  return channel_id_;
}

void DataChannelMessage::set_channel_id(std::string_view value_arg) {
  channel_id_ = value_arg;
}


const std::string& DataChannelMessage::type() const {
  return type_;
}

void DataChannelMessage::set_type(std::string_view value_arg) {
  type_ = value_arg;
}


const std::vector<uint8_t>* DataChannelMessage::binary() const {
  return binary_ ? &(*binary_) : nullptr;
}

void DataChannelMessage::set_binary(const std::vector<uint8_t>* value_arg) {
  binary_ = value_arg ? std::optional<std::vector<uint8_t>>(*value_arg) : std::nullopt;
}

void DataChannelMessage::set_binary(const std::vector<uint8_t>& value_arg) {
  binary_ = value_arg;
}


const std::string* DataChannelMessage::text() const {
  return text_ ? &(*text_) : nullptr;
}

void DataChannelMessage::set_text(const std::string_view* value_arg) {
  text_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void DataChannelMessage::set_text(std::string_view value_arg) {
  text_ = value_arg;
}


EncodableList DataChannelMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(4);
  list.push_back(EncodableValue(channel_id_));
  list.push_back(EncodableValue(type_));
  list.push_back(binary_ ? EncodableValue(*binary_) : EncodableValue());
  list.push_back(text_ ? EncodableValue(*text_) : EncodableValue());
  return list;
}

DataChannelMessage DataChannelMessage::FromEncodableList(const EncodableList& list) {
  DataChannelMessage decoded(
    std::get<std::string>(list[0]),
    std::get<std::string>(list[1]));
  auto& encodable_binary = list[2];
  if (!encodable_binary.IsNull()) {
    decoded.set_binary(std::get<std::vector<uint8_t>>(encodable_binary));
  }
  auto& encodable_text = list[3];
  if (!encodable_text.IsNull()) {
    decoded.set_text(std::get<std::string>(encodable_text));
  }
  return decoded;
}

// DataChannelInitMessage

DataChannelInitMessage::DataChannelInitMessage(
  int64_t id,
  bool negotiated,
  const std::string& binary_type,
  const std::string& protocol,
  bool ordered,
  int64_t max_retransmit_time,
  int64_t max_retransmits)
 : id_(id),
    negotiated_(negotiated),
    binary_type_(binary_type),
    protocol_(protocol),
    ordered_(ordered),
    max_retransmit_time_(max_retransmit_time),
    max_retransmits_(max_retransmits) {}

int64_t DataChannelInitMessage::id() const {
  return id_;
}

void DataChannelInitMessage::set_id(int64_t value_arg) {
  id_ = value_arg;
}


bool DataChannelInitMessage::negotiated() const {
  return negotiated_;
}

void DataChannelInitMessage::set_negotiated(bool value_arg) {
  negotiated_ = value_arg;
}


const std::string& DataChannelInitMessage::binary_type() const {
  return binary_type_;
}

void DataChannelInitMessage::set_binary_type(std::string_view value_arg) {
  binary_type_ = value_arg;
}


const std::string& DataChannelInitMessage::protocol() const {
  return protocol_;
}

void DataChannelInitMessage::set_protocol(std::string_view value_arg) {
  protocol_ = value_arg;
}


bool DataChannelInitMessage::ordered() const {
  return ordered_;
}

void DataChannelInitMessage::set_ordered(bool value_arg) {
  ordered_ = value_arg;
}


int64_t DataChannelInitMessage::max_retransmit_time() const {
  return max_retransmit_time_;
}

void DataChannelInitMessage::set_max_retransmit_time(int64_t value_arg) {
  max_retransmit_time_ = value_arg;
}


int64_t DataChannelInitMessage::max_retransmits() const {
  return max_retransmits_;
}

void DataChannelInitMessage::set_max_retransmits(int64_t value_arg) {
  max_retransmits_ = value_arg;
}


EncodableList DataChannelInitMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(7);
  list.push_back(EncodableValue(id_));
  list.push_back(EncodableValue(negotiated_));
  list.push_back(EncodableValue(binary_type_));
  list.push_back(EncodableValue(protocol_));
  list.push_back(EncodableValue(ordered_));
  list.push_back(EncodableValue(max_retransmit_time_));
  list.push_back(EncodableValue(max_retransmits_));
  return list;
}

DataChannelInitMessage DataChannelInitMessage::FromEncodableList(const EncodableList& list) {
  DataChannelInitMessage decoded(
    list[0].LongValue(),
    std::get<bool>(list[1]),
    std::get<std::string>(list[2]),
    std::get<std::string>(list[3]),
    std::get<bool>(list[4]),
    list[5].LongValue(),
    list[6].LongValue());
  return decoded;
}

// HeaderExtensionMessage

HeaderExtensionMessage::HeaderExtensionMessage() {}

HeaderExtensionMessage::HeaderExtensionMessage(
  const std::string* uri,
  const int64_t* id,
  const bool* encrypted)
 : uri_(uri ? std::optional<std::string>(*uri) : std::nullopt),
    id_(id ? std::optional<int64_t>(*id) : std::nullopt),
    encrypted_(encrypted ? std::optional<bool>(*encrypted) : std::nullopt) {}

const std::string* HeaderExtensionMessage::uri() const {
  return uri_ ? &(*uri_) : nullptr;
}

void HeaderExtensionMessage::set_uri(const std::string_view* value_arg) {
  uri_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void HeaderExtensionMessage::set_uri(std::string_view value_arg) {
  uri_ = value_arg;
}


const int64_t* HeaderExtensionMessage::id() const {
  return id_ ? &(*id_) : nullptr;
}

void HeaderExtensionMessage::set_id(const int64_t* value_arg) {
  id_ = value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void HeaderExtensionMessage::set_id(int64_t value_arg) {
  id_ = value_arg;
}


const bool* HeaderExtensionMessage::encrypted() const {
  return encrypted_ ? &(*encrypted_) : nullptr;
}

void HeaderExtensionMessage::set_encrypted(const bool* value_arg) {
  encrypted_ = value_arg ? std::optional<bool>(*value_arg) : std::nullopt;
}

void HeaderExtensionMessage::set_encrypted(bool value_arg) {
  encrypted_ = value_arg;
}


EncodableList HeaderExtensionMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(3);
  list.push_back(uri_ ? EncodableValue(*uri_) : EncodableValue());
  list.push_back(id_ ? EncodableValue(*id_) : EncodableValue());
  list.push_back(encrypted_ ? EncodableValue(*encrypted_) : EncodableValue());
  return list;
}

HeaderExtensionMessage HeaderExtensionMessage::FromEncodableList(const EncodableList& list) {
  HeaderExtensionMessage decoded;
  auto& encodable_uri = list[0];
  if (!encodable_uri.IsNull()) {
    decoded.set_uri(std::get<std::string>(encodable_uri));
  }
  auto& encodable_id = list[1];
  if (!encodable_id.IsNull()) {
    decoded.set_id(encodable_id.LongValue());
  }
  auto& encodable_encrypted = list[2];
  if (!encodable_encrypted.IsNull()) {
    decoded.set_encrypted(std::get<bool>(encodable_encrypted));
  }
  return decoded;
}

// RtpEncodingMessage

RtpEncodingMessage::RtpEncodingMessage(bool active)
 : active_(active) {}

RtpEncodingMessage::RtpEncodingMessage(
  bool active,
  const std::string* rid,
  const int64_t* max_bitrate,
  const int64_t* min_bitrate,
  const int64_t* max_framerate,
  const int64_t* num_temporal_layers,
  const double* scale_resolution_down_by,
  const int64_t* ssrc,
  const std::string* scalability_mode)
 : active_(active),
    rid_(rid ? std::optional<std::string>(*rid) : std::nullopt),
    max_bitrate_(max_bitrate ? std::optional<int64_t>(*max_bitrate) : std::nullopt),
    min_bitrate_(min_bitrate ? std::optional<int64_t>(*min_bitrate) : std::nullopt),
    max_framerate_(max_framerate ? std::optional<int64_t>(*max_framerate) : std::nullopt),
    num_temporal_layers_(num_temporal_layers ? std::optional<int64_t>(*num_temporal_layers) : std::nullopt),
    scale_resolution_down_by_(scale_resolution_down_by ? std::optional<double>(*scale_resolution_down_by) : std::nullopt),
    ssrc_(ssrc ? std::optional<int64_t>(*ssrc) : std::nullopt),
    scalability_mode_(scalability_mode ? std::optional<std::string>(*scalability_mode) : std::nullopt) {}

bool RtpEncodingMessage::active() const {
  return active_;
}

void RtpEncodingMessage::set_active(bool value_arg) {
  active_ = value_arg;
}


const std::string* RtpEncodingMessage::rid() const {
  return rid_ ? &(*rid_) : nullptr;
}

void RtpEncodingMessage::set_rid(const std::string_view* value_arg) {
  rid_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void RtpEncodingMessage::set_rid(std::string_view value_arg) {
  rid_ = value_arg;
}


const int64_t* RtpEncodingMessage::max_bitrate() const {
  return max_bitrate_ ? &(*max_bitrate_) : nullptr;
}

void RtpEncodingMessage::set_max_bitrate(const int64_t* value_arg) {
  max_bitrate_ = value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void RtpEncodingMessage::set_max_bitrate(int64_t value_arg) {
  max_bitrate_ = value_arg;
}


const int64_t* RtpEncodingMessage::min_bitrate() const {
  return min_bitrate_ ? &(*min_bitrate_) : nullptr;
}

void RtpEncodingMessage::set_min_bitrate(const int64_t* value_arg) {
  min_bitrate_ = value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void RtpEncodingMessage::set_min_bitrate(int64_t value_arg) {
  min_bitrate_ = value_arg;
}


const int64_t* RtpEncodingMessage::max_framerate() const {
  return max_framerate_ ? &(*max_framerate_) : nullptr;
}

void RtpEncodingMessage::set_max_framerate(const int64_t* value_arg) {
  max_framerate_ = value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void RtpEncodingMessage::set_max_framerate(int64_t value_arg) {
  max_framerate_ = value_arg;
}


const int64_t* RtpEncodingMessage::num_temporal_layers() const {
  return num_temporal_layers_ ? &(*num_temporal_layers_) : nullptr;
}

void RtpEncodingMessage::set_num_temporal_layers(const int64_t* value_arg) {
  num_temporal_layers_ = value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void RtpEncodingMessage::set_num_temporal_layers(int64_t value_arg) {
  num_temporal_layers_ = value_arg;
}


const double* RtpEncodingMessage::scale_resolution_down_by() const {
  return scale_resolution_down_by_ ? &(*scale_resolution_down_by_) : nullptr;
}

void RtpEncodingMessage::set_scale_resolution_down_by(const double* value_arg) {
  scale_resolution_down_by_ = value_arg ? std::optional<double>(*value_arg) : std::nullopt;
}

void RtpEncodingMessage::set_scale_resolution_down_by(double value_arg) {
  scale_resolution_down_by_ = value_arg;
}


const int64_t* RtpEncodingMessage::ssrc() const {
  return ssrc_ ? &(*ssrc_) : nullptr;
}

void RtpEncodingMessage::set_ssrc(const int64_t* value_arg) {
  ssrc_ = value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void RtpEncodingMessage::set_ssrc(int64_t value_arg) {
  ssrc_ = value_arg;
}


const std::string* RtpEncodingMessage::scalability_mode() const {
  return scalability_mode_ ? &(*scalability_mode_) : nullptr;
}

void RtpEncodingMessage::set_scalability_mode(const std::string_view* value_arg) {
  scalability_mode_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void RtpEncodingMessage::set_scalability_mode(std::string_view value_arg) {
  scalability_mode_ = value_arg;
}


EncodableList RtpEncodingMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(9);
  list.push_back(EncodableValue(active_));
  list.push_back(rid_ ? EncodableValue(*rid_) : EncodableValue());
  list.push_back(max_bitrate_ ? EncodableValue(*max_bitrate_) : EncodableValue());
  list.push_back(min_bitrate_ ? EncodableValue(*min_bitrate_) : EncodableValue());
  list.push_back(max_framerate_ ? EncodableValue(*max_framerate_) : EncodableValue());
  list.push_back(num_temporal_layers_ ? EncodableValue(*num_temporal_layers_) : EncodableValue());
  list.push_back(scale_resolution_down_by_ ? EncodableValue(*scale_resolution_down_by_) : EncodableValue());
  list.push_back(ssrc_ ? EncodableValue(*ssrc_) : EncodableValue());
  list.push_back(scalability_mode_ ? EncodableValue(*scalability_mode_) : EncodableValue());
  return list;
}

RtpEncodingMessage RtpEncodingMessage::FromEncodableList(const EncodableList& list) {
  RtpEncodingMessage decoded(
    std::get<bool>(list[0]));
  auto& encodable_rid = list[1];
  if (!encodable_rid.IsNull()) {
    decoded.set_rid(std::get<std::string>(encodable_rid));
  }
  auto& encodable_max_bitrate = list[2];
  if (!encodable_max_bitrate.IsNull()) {
    decoded.set_max_bitrate(encodable_max_bitrate.LongValue());
  }
  auto& encodable_min_bitrate = list[3];
  if (!encodable_min_bitrate.IsNull()) {
    decoded.set_min_bitrate(encodable_min_bitrate.LongValue());
  }
  auto& encodable_max_framerate = list[4];
  if (!encodable_max_framerate.IsNull()) {
    decoded.set_max_framerate(encodable_max_framerate.LongValue());
  }
  auto& encodable_num_temporal_layers = list[5];
  if (!encodable_num_temporal_layers.IsNull()) {
    decoded.set_num_temporal_layers(encodable_num_temporal_layers.LongValue());
  }
  auto& encodable_scale_resolution_down_by = list[6];
  if (!encodable_scale_resolution_down_by.IsNull()) {
    decoded.set_scale_resolution_down_by(std::get<double>(encodable_scale_resolution_down_by));
  }
  auto& encodable_ssrc = list[7];
  if (!encodable_ssrc.IsNull()) {
    decoded.set_ssrc(encodable_ssrc.LongValue());
  }
  auto& encodable_scalability_mode = list[8];
  if (!encodable_scalability_mode.IsNull()) {
    decoded.set_scalability_mode(std::get<std::string>(encodable_scalability_mode));
  }
  return decoded;
}

// RtpCodecMessage

RtpCodecMessage::RtpCodecMessage() {}

RtpCodecMessage::RtpCodecMessage(
  const int64_t* payload_type,
  const std::string* name,
  const std::string* kind,
  const int64_t* clock_rate,
  const int64_t* num_channels,
  const EncodableMap* parameters)
 : payload_type_(payload_type ? std::optional<int64_t>(*payload_type) : std::nullopt),
    name_(name ? std::optional<std::string>(*name) : std::nullopt),
    kind_(kind ? std::optional<std::string>(*kind) : std::nullopt),
    clock_rate_(clock_rate ? std::optional<int64_t>(*clock_rate) : std::nullopt),
    num_channels_(num_channels ? std::optional<int64_t>(*num_channels) : std::nullopt),
    parameters_(parameters ? std::optional<EncodableMap>(*parameters) : std::nullopt) {}

const int64_t* RtpCodecMessage::payload_type() const {
  return payload_type_ ? &(*payload_type_) : nullptr;
}

void RtpCodecMessage::set_payload_type(const int64_t* value_arg) {
  payload_type_ = value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void RtpCodecMessage::set_payload_type(int64_t value_arg) {
  payload_type_ = value_arg;
}


const std::string* RtpCodecMessage::name() const {
  return name_ ? &(*name_) : nullptr;
}

void RtpCodecMessage::set_name(const std::string_view* value_arg) {
  name_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void RtpCodecMessage::set_name(std::string_view value_arg) {
  name_ = value_arg;
}


const std::string* RtpCodecMessage::kind() const {
  return kind_ ? &(*kind_) : nullptr;
}

void RtpCodecMessage::set_kind(const std::string_view* value_arg) {
  kind_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void RtpCodecMessage::set_kind(std::string_view value_arg) {
  kind_ = value_arg;
}


const int64_t* RtpCodecMessage::clock_rate() const {
  return clock_rate_ ? &(*clock_rate_) : nullptr;
}

void RtpCodecMessage::set_clock_rate(const int64_t* value_arg) {
  clock_rate_ = value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void RtpCodecMessage::set_clock_rate(int64_t value_arg) {
  clock_rate_ = value_arg;
}


const int64_t* RtpCodecMessage::num_channels() const {
  return num_channels_ ? &(*num_channels_) : nullptr;
}

void RtpCodecMessage::set_num_channels(const int64_t* value_arg) {
  num_channels_ = value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void RtpCodecMessage::set_num_channels(int64_t value_arg) {
  num_channels_ = value_arg;
}


const EncodableMap* RtpCodecMessage::parameters() const {
  return parameters_ ? &(*parameters_) : nullptr;
}

void RtpCodecMessage::set_parameters(const EncodableMap* value_arg) {
  parameters_ = value_arg ? std::optional<EncodableMap>(*value_arg) : std::nullopt;
}

void RtpCodecMessage::set_parameters(const EncodableMap& value_arg) {
  parameters_ = value_arg;
}


EncodableList RtpCodecMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(6);
  list.push_back(payload_type_ ? EncodableValue(*payload_type_) : EncodableValue());
  list.push_back(name_ ? EncodableValue(*name_) : EncodableValue());
  list.push_back(kind_ ? EncodableValue(*kind_) : EncodableValue());
  list.push_back(clock_rate_ ? EncodableValue(*clock_rate_) : EncodableValue());
  list.push_back(num_channels_ ? EncodableValue(*num_channels_) : EncodableValue());
  list.push_back(parameters_ ? EncodableValue(*parameters_) : EncodableValue());
  return list;
}

RtpCodecMessage RtpCodecMessage::FromEncodableList(const EncodableList& list) {
  RtpCodecMessage decoded;
  auto& encodable_payload_type = list[0];
  if (!encodable_payload_type.IsNull()) {
    decoded.set_payload_type(encodable_payload_type.LongValue());
  }
  auto& encodable_name = list[1];
  if (!encodable_name.IsNull()) {
    decoded.set_name(std::get<std::string>(encodable_name));
  }
  auto& encodable_kind = list[2];
  if (!encodable_kind.IsNull()) {
    decoded.set_kind(std::get<std::string>(encodable_kind));
  }
  auto& encodable_clock_rate = list[3];
  if (!encodable_clock_rate.IsNull()) {
    decoded.set_clock_rate(encodable_clock_rate.LongValue());
  }
  auto& encodable_num_channels = list[4];
  if (!encodable_num_channels.IsNull()) {
    decoded.set_num_channels(encodable_num_channels.LongValue());
  }
  auto& encodable_parameters = list[5];
  if (!encodable_parameters.IsNull()) {
    decoded.set_parameters(std::get<EncodableMap>(encodable_parameters));
  }
  return decoded;
}

// RTCParametersMessage

RTCParametersMessage::RTCParametersMessage(
  const std::string& cname,
  bool reduced_size)
 : cname_(cname),
    reduced_size_(reduced_size) {}

const std::string& RTCParametersMessage::cname() const {
  return cname_;
}

void RTCParametersMessage::set_cname(std::string_view value_arg) {
  cname_ = value_arg;
}


bool RTCParametersMessage::reduced_size() const {
  return reduced_size_;
}

void RTCParametersMessage::set_reduced_size(bool value_arg) {
  reduced_size_ = value_arg;
}


EncodableList RTCParametersMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(2);
  list.push_back(EncodableValue(cname_));
  list.push_back(EncodableValue(reduced_size_));
  return list;
}

RTCParametersMessage RTCParametersMessage::FromEncodableList(const EncodableList& list) {
  RTCParametersMessage decoded(
    std::get<std::string>(list[0]),
    std::get<bool>(list[1]));
  return decoded;
}

// RtpParametersMessage

RtpParametersMessage::RtpParametersMessage() {}

RtpParametersMessage::RtpParametersMessage(
  const std::string* transaction_id,
  const RTCParametersMessage* rtcp,
  const EncodableList* header_extensions,
  const EncodableList* encodings,
  const EncodableList* codecs)
 : transaction_id_(transaction_id ? std::optional<std::string>(*transaction_id) : std::nullopt),
    rtcp_(rtcp ? std::optional<RTCParametersMessage>(*rtcp) : std::nullopt),
    header_extensions_(header_extensions ? std::optional<EncodableList>(*header_extensions) : std::nullopt),
    encodings_(encodings ? std::optional<EncodableList>(*encodings) : std::nullopt),
    codecs_(codecs ? std::optional<EncodableList>(*codecs) : std::nullopt) {}

const std::string* RtpParametersMessage::transaction_id() const {
  return transaction_id_ ? &(*transaction_id_) : nullptr;
}

void RtpParametersMessage::set_transaction_id(const std::string_view* value_arg) {
  transaction_id_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void RtpParametersMessage::set_transaction_id(std::string_view value_arg) {
  transaction_id_ = value_arg;
}


const RTCParametersMessage* RtpParametersMessage::rtcp() const {
  return rtcp_ ? &(*rtcp_) : nullptr;
}

void RtpParametersMessage::set_rtcp(const RTCParametersMessage* value_arg) {
  rtcp_ = value_arg ? std::optional<RTCParametersMessage>(*value_arg) : std::nullopt;
}

void RtpParametersMessage::set_rtcp(const RTCParametersMessage& value_arg) {
  rtcp_ = value_arg;
}


const EncodableList* RtpParametersMessage::header_extensions() const {
  return header_extensions_ ? &(*header_extensions_) : nullptr;
}

void RtpParametersMessage::set_header_extensions(const EncodableList* value_arg) {
  header_extensions_ = value_arg ? std::optional<EncodableList>(*value_arg) : std::nullopt;
}

void RtpParametersMessage::set_header_extensions(const EncodableList& value_arg) {
  header_extensions_ = value_arg;
}


const EncodableList* RtpParametersMessage::encodings() const {
  return encodings_ ? &(*encodings_) : nullptr;
}

void RtpParametersMessage::set_encodings(const EncodableList* value_arg) {
  encodings_ = value_arg ? std::optional<EncodableList>(*value_arg) : std::nullopt;
}

void RtpParametersMessage::set_encodings(const EncodableList& value_arg) {
  encodings_ = value_arg;
}


const EncodableList* RtpParametersMessage::codecs() const {
  return codecs_ ? &(*codecs_) : nullptr;
}

void RtpParametersMessage::set_codecs(const EncodableList* value_arg) {
  codecs_ = value_arg ? std::optional<EncodableList>(*value_arg) : std::nullopt;
}

void RtpParametersMessage::set_codecs(const EncodableList& value_arg) {
  codecs_ = value_arg;
}


EncodableList RtpParametersMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(5);
  list.push_back(transaction_id_ ? EncodableValue(*transaction_id_) : EncodableValue());
  list.push_back(rtcp_ ? EncodableValue(rtcp_->ToEncodableList()) : EncodableValue());
  list.push_back(header_extensions_ ? EncodableValue(*header_extensions_) : EncodableValue());
  list.push_back(encodings_ ? EncodableValue(*encodings_) : EncodableValue());
  list.push_back(codecs_ ? EncodableValue(*codecs_) : EncodableValue());
  return list;
}

RtpParametersMessage RtpParametersMessage::FromEncodableList(const EncodableList& list) {
  RtpParametersMessage decoded;
  auto& encodable_transaction_id = list[0];
  if (!encodable_transaction_id.IsNull()) {
    decoded.set_transaction_id(std::get<std::string>(encodable_transaction_id));
  }
  auto& encodable_rtcp = list[1];
  if (!encodable_rtcp.IsNull()) {
    decoded.set_rtcp(RTCParametersMessage::FromEncodableList(std::get<EncodableList>(encodable_rtcp)));
  }
  auto& encodable_header_extensions = list[2];
  if (!encodable_header_extensions.IsNull()) {
    decoded.set_header_extensions(std::get<EncodableList>(encodable_header_extensions));
  }
  auto& encodable_encodings = list[3];
  if (!encodable_encodings.IsNull()) {
    decoded.set_encodings(std::get<EncodableList>(encodable_encodings));
  }
  auto& encodable_codecs = list[4];
  if (!encodable_codecs.IsNull()) {
    decoded.set_codecs(std::get<EncodableList>(encodable_codecs));
  }
  return decoded;
}

// RtpCodecCapabilityMessage

RtpCodecCapabilityMessage::RtpCodecCapabilityMessage(
  int64_t clock_rate,
  const std::string& mime_type)
 : clock_rate_(clock_rate),
    mime_type_(mime_type) {}

RtpCodecCapabilityMessage::RtpCodecCapabilityMessage(
  const int64_t* channels,
  int64_t clock_rate,
  const std::string& mime_type,
  const std::string* sdp_fmtp_line)
 : channels_(channels ? std::optional<int64_t>(*channels) : std::nullopt),
    clock_rate_(clock_rate),
    mime_type_(mime_type),
    sdp_fmtp_line_(sdp_fmtp_line ? std::optional<std::string>(*sdp_fmtp_line) : std::nullopt) {}

const int64_t* RtpCodecCapabilityMessage::channels() const {
  return channels_ ? &(*channels_) : nullptr;
}

void RtpCodecCapabilityMessage::set_channels(const int64_t* value_arg) {
  channels_ = value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void RtpCodecCapabilityMessage::set_channels(int64_t value_arg) {
  channels_ = value_arg;
}


int64_t RtpCodecCapabilityMessage::clock_rate() const {
  return clock_rate_;
}

void RtpCodecCapabilityMessage::set_clock_rate(int64_t value_arg) {
  clock_rate_ = value_arg;
}


const std::string& RtpCodecCapabilityMessage::mime_type() const {
  return mime_type_;
}

void RtpCodecCapabilityMessage::set_mime_type(std::string_view value_arg) {
  mime_type_ = value_arg;
}


const std::string* RtpCodecCapabilityMessage::sdp_fmtp_line() const {
  return sdp_fmtp_line_ ? &(*sdp_fmtp_line_) : nullptr;
}

void RtpCodecCapabilityMessage::set_sdp_fmtp_line(const std::string_view* value_arg) {
  sdp_fmtp_line_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void RtpCodecCapabilityMessage::set_sdp_fmtp_line(std::string_view value_arg) {
  sdp_fmtp_line_ = value_arg;
}


EncodableList RtpCodecCapabilityMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(4);
  list.push_back(channels_ ? EncodableValue(*channels_) : EncodableValue());
  list.push_back(EncodableValue(clock_rate_));
  list.push_back(EncodableValue(mime_type_));
  list.push_back(sdp_fmtp_line_ ? EncodableValue(*sdp_fmtp_line_) : EncodableValue());
  return list;
}

RtpCodecCapabilityMessage RtpCodecCapabilityMessage::FromEncodableList(const EncodableList& list) {
  RtpCodecCapabilityMessage decoded(
    list[1].LongValue(),
    std::get<std::string>(list[2]));
  auto& encodable_channels = list[0];
  if (!encodable_channels.IsNull()) {
    decoded.set_channels(encodable_channels.LongValue());
  }
  auto& encodable_sdp_fmtp_line = list[3];
  if (!encodable_sdp_fmtp_line.IsNull()) {
    decoded.set_sdp_fmtp_line(std::get<std::string>(encodable_sdp_fmtp_line));
  }
  return decoded;
}

// RtpHeaderExtensionCapabilityMessage

RtpHeaderExtensionCapabilityMessage::RtpHeaderExtensionCapabilityMessage(const std::string& uri)
 : uri_(uri) {}

const std::string& RtpHeaderExtensionCapabilityMessage::uri() const {
  return uri_;
}

void RtpHeaderExtensionCapabilityMessage::set_uri(std::string_view value_arg) {
  uri_ = value_arg;
}


EncodableList RtpHeaderExtensionCapabilityMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(1);
  list.push_back(EncodableValue(uri_));
  return list;
}

RtpHeaderExtensionCapabilityMessage RtpHeaderExtensionCapabilityMessage::FromEncodableList(const EncodableList& list) {
  RtpHeaderExtensionCapabilityMessage decoded(
    std::get<std::string>(list[0]));
  return decoded;
}

// RtpCapabilitiesMessage

RtpCapabilitiesMessage::RtpCapabilitiesMessage() {}

RtpCapabilitiesMessage::RtpCapabilitiesMessage(
  const EncodableList* codecs,
  const EncodableList* header_extensions,
  const EncodableList* fec_mechanisms)
 : codecs_(codecs ? std::optional<EncodableList>(*codecs) : std::nullopt),
    header_extensions_(header_extensions ? std::optional<EncodableList>(*header_extensions) : std::nullopt),
    fec_mechanisms_(fec_mechanisms ? std::optional<EncodableList>(*fec_mechanisms) : std::nullopt) {}

const EncodableList* RtpCapabilitiesMessage::codecs() const {
  return codecs_ ? &(*codecs_) : nullptr;
}

void RtpCapabilitiesMessage::set_codecs(const EncodableList* value_arg) {
  codecs_ = value_arg ? std::optional<EncodableList>(*value_arg) : std::nullopt;
}

void RtpCapabilitiesMessage::set_codecs(const EncodableList& value_arg) {
  codecs_ = value_arg;
}


const EncodableList* RtpCapabilitiesMessage::header_extensions() const {
  return header_extensions_ ? &(*header_extensions_) : nullptr;
}

void RtpCapabilitiesMessage::set_header_extensions(const EncodableList* value_arg) {
  header_extensions_ = value_arg ? std::optional<EncodableList>(*value_arg) : std::nullopt;
}

void RtpCapabilitiesMessage::set_header_extensions(const EncodableList& value_arg) {
  header_extensions_ = value_arg;
}


const EncodableList* RtpCapabilitiesMessage::fec_mechanisms() const {
  return fec_mechanisms_ ? &(*fec_mechanisms_) : nullptr;
}

void RtpCapabilitiesMessage::set_fec_mechanisms(const EncodableList* value_arg) {
  fec_mechanisms_ = value_arg ? std::optional<EncodableList>(*value_arg) : std::nullopt;
}

void RtpCapabilitiesMessage::set_fec_mechanisms(const EncodableList& value_arg) {
  fec_mechanisms_ = value_arg;
}


EncodableList RtpCapabilitiesMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(3);
  list.push_back(codecs_ ? EncodableValue(*codecs_) : EncodableValue());
  list.push_back(header_extensions_ ? EncodableValue(*header_extensions_) : EncodableValue());
  list.push_back(fec_mechanisms_ ? EncodableValue(*fec_mechanisms_) : EncodableValue());
  return list;
}

RtpCapabilitiesMessage RtpCapabilitiesMessage::FromEncodableList(const EncodableList& list) {
  RtpCapabilitiesMessage decoded;
  auto& encodable_codecs = list[0];
  if (!encodable_codecs.IsNull()) {
    decoded.set_codecs(std::get<EncodableList>(encodable_codecs));
  }
  auto& encodable_header_extensions = list[1];
  if (!encodable_header_extensions.IsNull()) {
    decoded.set_header_extensions(std::get<EncodableList>(encodable_header_extensions));
  }
  auto& encodable_fec_mechanisms = list[2];
  if (!encodable_fec_mechanisms.IsNull()) {
    decoded.set_fec_mechanisms(std::get<EncodableList>(encodable_fec_mechanisms));
  }
  return decoded;
}

// ThumbnailSizeMessage

ThumbnailSizeMessage::ThumbnailSizeMessage(
  int64_t width,
  int64_t height)
 : width_(width),
    height_(height) {}

int64_t ThumbnailSizeMessage::width() const {
  return width_;
}

void ThumbnailSizeMessage::set_width(int64_t value_arg) {
  width_ = value_arg;
}


int64_t ThumbnailSizeMessage::height() const {
  return height_;
}

void ThumbnailSizeMessage::set_height(int64_t value_arg) {
  height_ = value_arg;
}


EncodableList ThumbnailSizeMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(2);
  list.push_back(EncodableValue(width_));
  list.push_back(EncodableValue(height_));
  return list;
}

ThumbnailSizeMessage ThumbnailSizeMessage::FromEncodableList(const EncodableList& list) {
  ThumbnailSizeMessage decoded(
    list[0].LongValue(),
    list[1].LongValue());
  return decoded;
}

// DesktopCapturerSourceMessage

DesktopCapturerSourceMessage::DesktopCapturerSourceMessage(
  const std::string& id,
  const std::string& name,
  const std::string& type,
  const ThumbnailSizeMessage& thumbnail_size_message)
 : id_(id),
    name_(name),
    type_(type),
    thumbnail_size_message_(thumbnail_size_message) {}

const std::string& DesktopCapturerSourceMessage::id() const {
  return id_;
}

void DesktopCapturerSourceMessage::set_id(std::string_view value_arg) {
  id_ = value_arg;
}


const std::string& DesktopCapturerSourceMessage::name() const {
  return name_;
}

void DesktopCapturerSourceMessage::set_name(std::string_view value_arg) {
  name_ = value_arg;
}


const std::string& DesktopCapturerSourceMessage::type() const {
  return type_;
}

void DesktopCapturerSourceMessage::set_type(std::string_view value_arg) {
  type_ = value_arg;
}


const ThumbnailSizeMessage& DesktopCapturerSourceMessage::thumbnail_size_message() const {
  return thumbnail_size_message_;
}

void DesktopCapturerSourceMessage::set_thumbnail_size_message(const ThumbnailSizeMessage& value_arg) {
  thumbnail_size_message_ = value_arg;
}


EncodableList DesktopCapturerSourceMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(4);
  list.push_back(EncodableValue(id_));
  list.push_back(EncodableValue(name_));
  list.push_back(EncodableValue(type_));
  list.push_back(EncodableValue(thumbnail_size_message_.ToEncodableList()));
  return list;
}

DesktopCapturerSourceMessage DesktopCapturerSourceMessage::FromEncodableList(const EncodableList& list) {
  DesktopCapturerSourceMessage decoded(
    std::get<std::string>(list[0]),
    std::get<std::string>(list[1]),
    std::get<std::string>(list[2]),
    ThumbnailSizeMessage::FromEncodableList(std::get<EncodableList>(list[3])));
  return decoded;
}


RTCPeerConnectionFactoryApiCodecSerializer::RTCPeerConnectionFactoryApiCodecSerializer() {}

EncodableValue RTCPeerConnectionFactoryApiCodecSerializer::ReadValueOfType(
  uint8_t type,
  flutter::ByteStreamReader* stream) const {
  switch (type) {
    case 128:
      return CustomEncodableValue(AudioTrackMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 129:
      return CustomEncodableValue(AudioTrackSettingsMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 130:
      return CustomEncodableValue(ConfigurationMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 131:
      return CustomEncodableValue(ConstraintsMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 132:
      return CustomEncodableValue(DataChannelInitMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 133:
      return CustomEncodableValue(DataChannelMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 134:
      return CustomEncodableValue(DesktopCapturerSourceMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 135:
      return CustomEncodableValue(HeaderExtensionMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 136:
      return CustomEncodableValue(IceCandidateMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 137:
      return CustomEncodableValue(MediaDeviceInfoMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 138:
      return CustomEncodableValue(MediaStreamMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 139:
      return CustomEncodableValue(RTCParametersMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 140:
      return CustomEncodableValue(RtpCapabilitiesMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 141:
      return CustomEncodableValue(RtpCodecCapabilityMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 142:
      return CustomEncodableValue(RtpCodecMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 143:
      return CustomEncodableValue(RtpEncodingMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 144:
      return CustomEncodableValue(RtpHeaderExtensionCapabilityMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 145:
      return CustomEncodableValue(RtpParametersMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 146:
      return CustomEncodableValue(SessionDescriptionMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 147:
      return CustomEncodableValue(StatsReportMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 148:
      return CustomEncodableValue(ThumbnailSizeMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 149:
      return CustomEncodableValue(VideoTrackMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 150:
      return CustomEncodableValue(VideoTrackSettingsMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    default:
      return flutter::StandardCodecSerializer::ReadValueOfType(type, stream);
  }
}

void RTCPeerConnectionFactoryApiCodecSerializer::WriteValue(
  const EncodableValue& value,
  flutter::ByteStreamWriter* stream) const {
  if (const CustomEncodableValue* custom_value = std::get_if<CustomEncodableValue>(&value)) {
    if (custom_value->type() == typeid(AudioTrackMessage)) {
      stream->WriteByte(128);
      WriteValue(EncodableValue(std::any_cast<AudioTrackMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(AudioTrackSettingsMessage)) {
      stream->WriteByte(129);
      WriteValue(EncodableValue(std::any_cast<AudioTrackSettingsMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(ConfigurationMessage)) {
      stream->WriteByte(130);
      WriteValue(EncodableValue(std::any_cast<ConfigurationMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(ConstraintsMessage)) {
      stream->WriteByte(131);
      WriteValue(EncodableValue(std::any_cast<ConstraintsMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(DataChannelInitMessage)) {
      stream->WriteByte(132);
      WriteValue(EncodableValue(std::any_cast<DataChannelInitMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(DataChannelMessage)) {
      stream->WriteByte(133);
      WriteValue(EncodableValue(std::any_cast<DataChannelMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(DesktopCapturerSourceMessage)) {
      stream->WriteByte(134);
      WriteValue(EncodableValue(std::any_cast<DesktopCapturerSourceMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(HeaderExtensionMessage)) {
      stream->WriteByte(135);
      WriteValue(EncodableValue(std::any_cast<HeaderExtensionMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(IceCandidateMessage)) {
      stream->WriteByte(136);
      WriteValue(EncodableValue(std::any_cast<IceCandidateMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(MediaDeviceInfoMessage)) {
      stream->WriteByte(137);
      WriteValue(EncodableValue(std::any_cast<MediaDeviceInfoMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(MediaStreamMessage)) {
      stream->WriteByte(138);
      WriteValue(EncodableValue(std::any_cast<MediaStreamMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(RTCParametersMessage)) {
      stream->WriteByte(139);
      WriteValue(EncodableValue(std::any_cast<RTCParametersMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(RtpCapabilitiesMessage)) {
      stream->WriteByte(140);
      WriteValue(EncodableValue(std::any_cast<RtpCapabilitiesMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(RtpCodecCapabilityMessage)) {
      stream->WriteByte(141);
      WriteValue(EncodableValue(std::any_cast<RtpCodecCapabilityMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(RtpCodecMessage)) {
      stream->WriteByte(142);
      WriteValue(EncodableValue(std::any_cast<RtpCodecMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(RtpEncodingMessage)) {
      stream->WriteByte(143);
      WriteValue(EncodableValue(std::any_cast<RtpEncodingMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(RtpHeaderExtensionCapabilityMessage)) {
      stream->WriteByte(144);
      WriteValue(EncodableValue(std::any_cast<RtpHeaderExtensionCapabilityMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(RtpParametersMessage)) {
      stream->WriteByte(145);
      WriteValue(EncodableValue(std::any_cast<RtpParametersMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(SessionDescriptionMessage)) {
      stream->WriteByte(146);
      WriteValue(EncodableValue(std::any_cast<SessionDescriptionMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(StatsReportMessage)) {
      stream->WriteByte(147);
      WriteValue(EncodableValue(std::any_cast<StatsReportMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(ThumbnailSizeMessage)) {
      stream->WriteByte(148);
      WriteValue(EncodableValue(std::any_cast<ThumbnailSizeMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(VideoTrackMessage)) {
      stream->WriteByte(149);
      WriteValue(EncodableValue(std::any_cast<VideoTrackMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(VideoTrackSettingsMessage)) {
      stream->WriteByte(150);
      WriteValue(EncodableValue(std::any_cast<VideoTrackSettingsMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
  }
  flutter::StandardCodecSerializer::WriteValue(value, stream);
}

/// The codec used by RTCPeerConnectionFactoryApi.
const flutter::StandardMessageCodec& RTCPeerConnectionFactoryApi::GetCodec() {
  return flutter::StandardMessageCodec::GetInstance(&RTCPeerConnectionFactoryApiCodecSerializer::GetInstance());
}

// Sets up an instance of `RTCPeerConnectionFactoryApi` to handle messages through the `binary_messenger`.
void RTCPeerConnectionFactoryApi::SetUp(
  flutter::BinaryMessenger* binary_messenger,
  RTCPeerConnectionFactoryApi* api) {
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCPeerConnectionFactoryApi.createPeerConnection", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_configuration_arg = args.at(0);
          if (encodable_configuration_arg.IsNull()) {
            reply(WrapError("configuration_arg unexpectedly null."));
            return;
          }
          const auto& configuration_arg = std::get<EncodableMap>(encodable_configuration_arg);
          const auto& encodable_constraints_arg = args.at(1);
          if (encodable_constraints_arg.IsNull()) {
            reply(WrapError("constraints_arg unexpectedly null."));
            return;
          }
          const auto& constraints_arg = std::get<EncodableMap>(encodable_constraints_arg);
          ErrorOr<std::string> output = api->CreatePeerConnection(configuration_arg, constraints_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCPeerConnectionFactoryApi.getRtpReceiverCapabilities", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_kind_arg = args.at(0);
          if (encodable_kind_arg.IsNull()) {
            reply(WrapError("kind_arg unexpectedly null."));
            return;
          }
          const auto& kind_arg = std::get<std::string>(encodable_kind_arg);
          ErrorOr<RtpCapabilitiesMessage> output = api->GetRtpReceiverCapabilities(kind_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCPeerConnectionFactoryApi.getRtpSenderCapabilities", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_kind_arg = args.at(0);
          if (encodable_kind_arg.IsNull()) {
            reply(WrapError("kind_arg unexpectedly null."));
            return;
          }
          const auto& kind_arg = std::get<std::string>(encodable_kind_arg);
          ErrorOr<RtpCapabilitiesMessage> output = api->GetRtpSenderCapabilities(kind_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
}

EncodableValue RTCPeerConnectionFactoryApi::WrapError(std::string_view error_message) {
  return EncodableValue(EncodableList{
    EncodableValue(std::string(error_message)),
    EncodableValue("Error"),
    EncodableValue()
  });
}

EncodableValue RTCPeerConnectionFactoryApi::WrapError(const FlutterError& error) {
  return EncodableValue(EncodableList{
    EncodableValue(error.code()),
    EncodableValue(error.message()),
    error.details()
  });
}


RTCPeerConnectionApiCodecSerializer::RTCPeerConnectionApiCodecSerializer() {}

EncodableValue RTCPeerConnectionApiCodecSerializer::ReadValueOfType(
  uint8_t type,
  flutter::ByteStreamReader* stream) const {
  switch (type) {
    case 128:
      return CustomEncodableValue(AudioTrackMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 129:
      return CustomEncodableValue(AudioTrackSettingsMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 130:
      return CustomEncodableValue(ConfigurationMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 131:
      return CustomEncodableValue(ConstraintsMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 132:
      return CustomEncodableValue(DataChannelInitMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 133:
      return CustomEncodableValue(DataChannelMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 134:
      return CustomEncodableValue(DesktopCapturerSourceMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 135:
      return CustomEncodableValue(HeaderExtensionMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 136:
      return CustomEncodableValue(IceCandidateMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 137:
      return CustomEncodableValue(MediaDeviceInfoMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 138:
      return CustomEncodableValue(MediaStreamMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 139:
      return CustomEncodableValue(RTCParametersMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 140:
      return CustomEncodableValue(RtpCapabilitiesMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 141:
      return CustomEncodableValue(RtpCodecCapabilityMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 142:
      return CustomEncodableValue(RtpCodecMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 143:
      return CustomEncodableValue(RtpEncodingMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 144:
      return CustomEncodableValue(RtpHeaderExtensionCapabilityMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 145:
      return CustomEncodableValue(RtpParametersMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 146:
      return CustomEncodableValue(SessionDescriptionMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 147:
      return CustomEncodableValue(StatsReportMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 148:
      return CustomEncodableValue(ThumbnailSizeMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 149:
      return CustomEncodableValue(VideoTrackMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 150:
      return CustomEncodableValue(VideoTrackSettingsMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    default:
      return flutter::StandardCodecSerializer::ReadValueOfType(type, stream);
  }
}

void RTCPeerConnectionApiCodecSerializer::WriteValue(
  const EncodableValue& value,
  flutter::ByteStreamWriter* stream) const {
  if (const CustomEncodableValue* custom_value = std::get_if<CustomEncodableValue>(&value)) {
    if (custom_value->type() == typeid(AudioTrackMessage)) {
      stream->WriteByte(128);
      WriteValue(EncodableValue(std::any_cast<AudioTrackMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(AudioTrackSettingsMessage)) {
      stream->WriteByte(129);
      WriteValue(EncodableValue(std::any_cast<AudioTrackSettingsMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(ConfigurationMessage)) {
      stream->WriteByte(130);
      WriteValue(EncodableValue(std::any_cast<ConfigurationMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(ConstraintsMessage)) {
      stream->WriteByte(131);
      WriteValue(EncodableValue(std::any_cast<ConstraintsMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(DataChannelInitMessage)) {
      stream->WriteByte(132);
      WriteValue(EncodableValue(std::any_cast<DataChannelInitMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(DataChannelMessage)) {
      stream->WriteByte(133);
      WriteValue(EncodableValue(std::any_cast<DataChannelMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(DesktopCapturerSourceMessage)) {
      stream->WriteByte(134);
      WriteValue(EncodableValue(std::any_cast<DesktopCapturerSourceMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(HeaderExtensionMessage)) {
      stream->WriteByte(135);
      WriteValue(EncodableValue(std::any_cast<HeaderExtensionMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(IceCandidateMessage)) {
      stream->WriteByte(136);
      WriteValue(EncodableValue(std::any_cast<IceCandidateMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(MediaDeviceInfoMessage)) {
      stream->WriteByte(137);
      WriteValue(EncodableValue(std::any_cast<MediaDeviceInfoMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(MediaStreamMessage)) {
      stream->WriteByte(138);
      WriteValue(EncodableValue(std::any_cast<MediaStreamMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(RTCParametersMessage)) {
      stream->WriteByte(139);
      WriteValue(EncodableValue(std::any_cast<RTCParametersMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(RtpCapabilitiesMessage)) {
      stream->WriteByte(140);
      WriteValue(EncodableValue(std::any_cast<RtpCapabilitiesMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(RtpCodecCapabilityMessage)) {
      stream->WriteByte(141);
      WriteValue(EncodableValue(std::any_cast<RtpCodecCapabilityMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(RtpCodecMessage)) {
      stream->WriteByte(142);
      WriteValue(EncodableValue(std::any_cast<RtpCodecMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(RtpEncodingMessage)) {
      stream->WriteByte(143);
      WriteValue(EncodableValue(std::any_cast<RtpEncodingMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(RtpHeaderExtensionCapabilityMessage)) {
      stream->WriteByte(144);
      WriteValue(EncodableValue(std::any_cast<RtpHeaderExtensionCapabilityMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(RtpParametersMessage)) {
      stream->WriteByte(145);
      WriteValue(EncodableValue(std::any_cast<RtpParametersMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(SessionDescriptionMessage)) {
      stream->WriteByte(146);
      WriteValue(EncodableValue(std::any_cast<SessionDescriptionMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(StatsReportMessage)) {
      stream->WriteByte(147);
      WriteValue(EncodableValue(std::any_cast<StatsReportMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(ThumbnailSizeMessage)) {
      stream->WriteByte(148);
      WriteValue(EncodableValue(std::any_cast<ThumbnailSizeMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(VideoTrackMessage)) {
      stream->WriteByte(149);
      WriteValue(EncodableValue(std::any_cast<VideoTrackMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(VideoTrackSettingsMessage)) {
      stream->WriteByte(150);
      WriteValue(EncodableValue(std::any_cast<VideoTrackSettingsMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
  }
  flutter::StandardCodecSerializer::WriteValue(value, stream);
}

/// The codec used by RTCPeerConnectionApi.
const flutter::StandardMessageCodec& RTCPeerConnectionApi::GetCodec() {
  return flutter::StandardMessageCodec::GetInstance(&RTCPeerConnectionApiCodecSerializer::GetInstance());
}

// Sets up an instance of `RTCPeerConnectionApi` to handle messages through the `binary_messenger`.
void RTCPeerConnectionApi::SetUp(
  flutter::BinaryMessenger* binary_messenger,
  RTCPeerConnectionApi* api) {
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCPeerConnectionApi.addCandidate", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_peer_connection_id_arg = args.at(0);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          const auto& encodable_msg_arg = args.at(1);
          if (encodable_msg_arg.IsNull()) {
            reply(WrapError("msg_arg unexpectedly null."));
            return;
          }
          const auto& msg_arg = std::any_cast<const IceCandidateMessage&>(std::get<CustomEncodableValue>(encodable_msg_arg));
          std::optional<FlutterError> output = api->AddCandidate(peer_connection_id_arg, msg_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCPeerConnectionApi.addStream", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_peer_connection_id_arg = args.at(0);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          const auto& encodable_stream_id_arg = args.at(1);
          if (encodable_stream_id_arg.IsNull()) {
            reply(WrapError("stream_id_arg unexpectedly null."));
            return;
          }
          const auto& stream_id_arg = std::get<std::string>(encodable_stream_id_arg);
          std::optional<FlutterError> output = api->AddStream(peer_connection_id_arg, stream_id_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCPeerConnectionApi.addTrack", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_peer_connection_id_arg = args.at(0);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          const auto& encodable_track_id_arg = args.at(1);
          if (encodable_track_id_arg.IsNull()) {
            reply(WrapError("track_id_arg unexpectedly null."));
            return;
          }
          const auto& track_id_arg = std::get<std::string>(encodable_track_id_arg);
          const auto& encodable_stream_ids_arg = args.at(2);
          const auto* stream_ids_arg = std::get_if<EncodableList>(&encodable_stream_ids_arg);
          ErrorOr<EncodableMap> output = api->AddTrack(peer_connection_id_arg, track_id_arg, stream_ids_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCPeerConnectionApi.closePeerConnection", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_peer_connection_id_arg = args.at(0);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          std::optional<FlutterError> output = api->ClosePeerConnection(peer_connection_id_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCPeerConnectionApi.createAnswer", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_peer_connection_id_arg = args.at(0);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          const auto& encodable_msg_arg = args.at(1);
          if (encodable_msg_arg.IsNull()) {
            reply(WrapError("msg_arg unexpectedly null."));
            return;
          }
          const auto& msg_arg = std::any_cast<const ConstraintsMessage&>(std::get<CustomEncodableValue>(encodable_msg_arg));
          ErrorOr<SessionDescriptionMessage> output = api->CreateAnswer(peer_connection_id_arg, msg_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCPeerConnectionApi.createDataChannel", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_peer_connection_id_arg = args.at(0);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          const auto& encodable_label_arg = args.at(1);
          if (encodable_label_arg.IsNull()) {
            reply(WrapError("label_arg unexpectedly null."));
            return;
          }
          const auto& label_arg = std::get<std::string>(encodable_label_arg);
          const auto& encodable_msg_arg = args.at(2);
          if (encodable_msg_arg.IsNull()) {
            reply(WrapError("msg_arg unexpectedly null."));
            return;
          }
          const auto& msg_arg = std::any_cast<const DataChannelInitMessage&>(std::get<CustomEncodableValue>(encodable_msg_arg));
          ErrorOr<EncodableMap> output = api->CreateDataChannel(peer_connection_id_arg, label_arg, msg_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCPeerConnectionApi.createOffer", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_peer_connection_id_arg = args.at(0);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          const auto& encodable_msg_arg = args.at(1);
          if (encodable_msg_arg.IsNull()) {
            reply(WrapError("msg_arg unexpectedly null."));
            return;
          }
          const auto& msg_arg = std::any_cast<const ConstraintsMessage&>(std::get<CustomEncodableValue>(encodable_msg_arg));
          ErrorOr<SessionDescriptionMessage> output = api->CreateOffer(peer_connection_id_arg, msg_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCPeerConnectionApi.disposePeerconnection", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_peer_connection_id_arg = args.at(0);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          std::optional<FlutterError> output = api->DisposePeerconnection(peer_connection_id_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCPeerConnectionApi.getLocalDescription", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_peer_connection_id_arg = args.at(0);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          ErrorOr<std::optional<SessionDescriptionMessage>> output = api->GetLocalDescription(peer_connection_id_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          auto output_optional = std::move(output).TakeValue();
          if (output_optional) {
            wrapped.push_back(CustomEncodableValue(std::move(output_optional).value()));
          } else {
            wrapped.push_back(EncodableValue());
          }
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCPeerConnectionApi.getLocalStreams", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_peer_connection_id_arg = args.at(0);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          ErrorOr<EncodableList> output = api->GetLocalStreams(peer_connection_id_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCPeerConnectionApi.getRemoteStreams", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_peer_connection_id_arg = args.at(0);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          ErrorOr<EncodableList> output = api->GetRemoteStreams(peer_connection_id_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCPeerConnectionApi.getReceivers", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_peer_connection_id_arg = args.at(0);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          ErrorOr<EncodableList> output = api->GetReceivers(peer_connection_id_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCPeerConnectionApi.getSenders", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_peer_connection_id_arg = args.at(0);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          ErrorOr<EncodableList> output = api->GetSenders(peer_connection_id_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCPeerConnectionApi.getTransceivers", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_peer_connection_id_arg = args.at(0);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          ErrorOr<EncodableList> output = api->GetTransceivers(peer_connection_id_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCPeerConnectionApi.getStats", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_peer_connection_id_arg = args.at(0);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          const auto& encodable_track_id_arg = args.at(1);
          if (encodable_track_id_arg.IsNull()) {
            reply(WrapError("track_id_arg unexpectedly null."));
            return;
          }
          const auto& track_id_arg = std::get<std::string>(encodable_track_id_arg);
          ErrorOr<EncodableList> output = api->GetStats(peer_connection_id_arg, track_id_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCPeerConnectionApi.removeStream", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_peer_connection_id_arg = args.at(0);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          const auto& encodable_stream_id_arg = args.at(1);
          if (encodable_stream_id_arg.IsNull()) {
            reply(WrapError("stream_id_arg unexpectedly null."));
            return;
          }
          const auto& stream_id_arg = std::get<std::string>(encodable_stream_id_arg);
          std::optional<FlutterError> output = api->RemoveStream(peer_connection_id_arg, stream_id_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCPeerConnectionApi.removeTrack", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_peer_connection_id_arg = args.at(0);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          const auto& encodable_sender_id_arg = args.at(1);
          if (encodable_sender_id_arg.IsNull()) {
            reply(WrapError("sender_id_arg unexpectedly null."));
            return;
          }
          const auto& sender_id_arg = std::get<std::string>(encodable_sender_id_arg);
          ErrorOr<bool> output = api->RemoveTrack(peer_connection_id_arg, sender_id_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCPeerConnectionApi.restartIce", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_peer_connection_id_arg = args.at(0);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          std::optional<FlutterError> output = api->RestartIce(peer_connection_id_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCPeerConnectionApi.setConfiguration", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_peer_connection_id_arg = args.at(0);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          const auto& encodable_msg_arg = args.at(1);
          if (encodable_msg_arg.IsNull()) {
            reply(WrapError("msg_arg unexpectedly null."));
            return;
          }
          const auto& msg_arg = std::any_cast<const ConfigurationMessage&>(std::get<CustomEncodableValue>(encodable_msg_arg));
          std::optional<FlutterError> output = api->SetConfiguration(peer_connection_id_arg, msg_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCPeerConnectionApi.setLocalDescription", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_peer_connection_id_arg = args.at(0);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          const auto& encodable_msg_arg = args.at(1);
          if (encodable_msg_arg.IsNull()) {
            reply(WrapError("msg_arg unexpectedly null."));
            return;
          }
          const auto& msg_arg = std::any_cast<const SessionDescriptionMessage&>(std::get<CustomEncodableValue>(encodable_msg_arg));
          std::optional<FlutterError> output = api->SetLocalDescription(peer_connection_id_arg, msg_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCPeerConnectionApi.getRemoteDescription", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_peer_connection_id_arg = args.at(0);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          ErrorOr<SessionDescriptionMessage> output = api->GetRemoteDescription(peer_connection_id_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCPeerConnectionApi.setRemoteDescription", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_peer_connection_id_arg = args.at(0);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          const auto& encodable_msg_arg = args.at(1);
          if (encodable_msg_arg.IsNull()) {
            reply(WrapError("msg_arg unexpectedly null."));
            return;
          }
          const auto& msg_arg = std::any_cast<const SessionDescriptionMessage&>(std::get<CustomEncodableValue>(encodable_msg_arg));
          std::optional<FlutterError> output = api->SetRemoteDescription(peer_connection_id_arg, msg_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
}

EncodableValue RTCPeerConnectionApi::WrapError(std::string_view error_message) {
  return EncodableValue(EncodableList{
    EncodableValue(std::string(error_message)),
    EncodableValue("Error"),
    EncodableValue()
  });
}

EncodableValue RTCPeerConnectionApi::WrapError(const FlutterError& error) {
  return EncodableValue(EncodableList{
    EncodableValue(error.code()),
    EncodableValue(error.message()),
    error.details()
  });
}


RTCDataChannelApiCodecSerializer::RTCDataChannelApiCodecSerializer() {}

EncodableValue RTCDataChannelApiCodecSerializer::ReadValueOfType(
  uint8_t type,
  flutter::ByteStreamReader* stream) const {
  switch (type) {
    case 128:
      return CustomEncodableValue(DataChannelMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    default:
      return flutter::StandardCodecSerializer::ReadValueOfType(type, stream);
  }
}

void RTCDataChannelApiCodecSerializer::WriteValue(
  const EncodableValue& value,
  flutter::ByteStreamWriter* stream) const {
  if (const CustomEncodableValue* custom_value = std::get_if<CustomEncodableValue>(&value)) {
    if (custom_value->type() == typeid(DataChannelMessage)) {
      stream->WriteByte(128);
      WriteValue(EncodableValue(std::any_cast<DataChannelMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
  }
  flutter::StandardCodecSerializer::WriteValue(value, stream);
}

/// The codec used by RTCDataChannelApi.
const flutter::StandardMessageCodec& RTCDataChannelApi::GetCodec() {
  return flutter::StandardMessageCodec::GetInstance(&RTCDataChannelApiCodecSerializer::GetInstance());
}

// Sets up an instance of `RTCDataChannelApi` to handle messages through the `binary_messenger`.
void RTCDataChannelApi::SetUp(
  flutter::BinaryMessenger* binary_messenger,
  RTCDataChannelApi* api) {
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCDataChannelApi.send", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_peer_connection_id_arg = args.at(0);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          const auto& encodable_message_arg = args.at(1);
          if (encodable_message_arg.IsNull()) {
            reply(WrapError("message_arg unexpectedly null."));
            return;
          }
          const auto& message_arg = std::any_cast<const DataChannelMessage&>(std::get<CustomEncodableValue>(encodable_message_arg));
          std::optional<FlutterError> output = api->Send(peer_connection_id_arg, message_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCDataChannelApi.closeDataChannel", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_peer_connection_id_arg = args.at(0);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          std::optional<FlutterError> output = api->CloseDataChannel(peer_connection_id_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
}

EncodableValue RTCDataChannelApi::WrapError(std::string_view error_message) {
  return EncodableValue(EncodableList{
    EncodableValue(std::string(error_message)),
    EncodableValue("Error"),
    EncodableValue()
  });
}

EncodableValue RTCDataChannelApi::WrapError(const FlutterError& error) {
  return EncodableValue(EncodableList{
    EncodableValue(error.code()),
    EncodableValue(error.message()),
    error.details()
  });
}

/// The codec used by RTCDTMFSenderApi.
const flutter::StandardMessageCodec& RTCDTMFSenderApi::GetCodec() {
  return flutter::StandardMessageCodec::GetInstance(&flutter::StandardCodecSerializer::GetInstance());
}

// Sets up an instance of `RTCDTMFSenderApi` to handle messages through the `binary_messenger`.
void RTCDTMFSenderApi::SetUp(
  flutter::BinaryMessenger* binary_messenger,
  RTCDTMFSenderApi* api) {
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCDTMFSenderApi.insertDtmf", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_peer_connection_id_arg = args.at(0);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          const auto& encodable_rtp_sender_id_arg = args.at(1);
          if (encodable_rtp_sender_id_arg.IsNull()) {
            reply(WrapError("rtp_sender_id_arg unexpectedly null."));
            return;
          }
          const auto& rtp_sender_id_arg = std::get<std::string>(encodable_rtp_sender_id_arg);
          const auto& encodable_tones_arg = args.at(2);
          if (encodable_tones_arg.IsNull()) {
            reply(WrapError("tones_arg unexpectedly null."));
            return;
          }
          const auto& tones_arg = std::get<std::string>(encodable_tones_arg);
          const auto& encodable_duration_arg = args.at(3);
          if (encodable_duration_arg.IsNull()) {
            reply(WrapError("duration_arg unexpectedly null."));
            return;
          }
          const int64_t duration_arg = encodable_duration_arg.LongValue();
          const auto& encodable_inter_tone_gap_arg = args.at(4);
          if (encodable_inter_tone_gap_arg.IsNull()) {
            reply(WrapError("inter_tone_gap_arg unexpectedly null."));
            return;
          }
          const int64_t inter_tone_gap_arg = encodable_inter_tone_gap_arg.LongValue();
          std::optional<FlutterError> output = api->InsertDtmf(peer_connection_id_arg, rtp_sender_id_arg, tones_arg, duration_arg, inter_tone_gap_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCDTMFSenderApi.canInsertDtmf", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_peer_connection_id_arg = args.at(0);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          const auto& encodable_rtp_sender_id_arg = args.at(1);
          if (encodable_rtp_sender_id_arg.IsNull()) {
            reply(WrapError("rtp_sender_id_arg unexpectedly null."));
            return;
          }
          const auto& rtp_sender_id_arg = std::get<std::string>(encodable_rtp_sender_id_arg);
          ErrorOr<bool> output = api->CanInsertDtmf(peer_connection_id_arg, rtp_sender_id_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
}

EncodableValue RTCDTMFSenderApi::WrapError(std::string_view error_message) {
  return EncodableValue(EncodableList{
    EncodableValue(std::string(error_message)),
    EncodableValue("Error"),
    EncodableValue()
  });
}

EncodableValue RTCDTMFSenderApi::WrapError(const FlutterError& error) {
  return EncodableValue(EncodableList{
    EncodableValue(error.code()),
    EncodableValue(error.message()),
    error.details()
  });
}


RTCRtpSenderApiCodecSerializer::RTCRtpSenderApiCodecSerializer() {}

EncodableValue RTCRtpSenderApiCodecSerializer::ReadValueOfType(
  uint8_t type,
  flutter::ByteStreamReader* stream) const {
  switch (type) {
    case 128:
      return CustomEncodableValue(HeaderExtensionMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 129:
      return CustomEncodableValue(RTCParametersMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 130:
      return CustomEncodableValue(RtpCodecMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 131:
      return CustomEncodableValue(RtpEncodingMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 132:
      return CustomEncodableValue(RtpParametersMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    default:
      return flutter::StandardCodecSerializer::ReadValueOfType(type, stream);
  }
}

void RTCRtpSenderApiCodecSerializer::WriteValue(
  const EncodableValue& value,
  flutter::ByteStreamWriter* stream) const {
  if (const CustomEncodableValue* custom_value = std::get_if<CustomEncodableValue>(&value)) {
    if (custom_value->type() == typeid(HeaderExtensionMessage)) {
      stream->WriteByte(128);
      WriteValue(EncodableValue(std::any_cast<HeaderExtensionMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(RTCParametersMessage)) {
      stream->WriteByte(129);
      WriteValue(EncodableValue(std::any_cast<RTCParametersMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(RtpCodecMessage)) {
      stream->WriteByte(130);
      WriteValue(EncodableValue(std::any_cast<RtpCodecMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(RtpEncodingMessage)) {
      stream->WriteByte(131);
      WriteValue(EncodableValue(std::any_cast<RtpEncodingMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(RtpParametersMessage)) {
      stream->WriteByte(132);
      WriteValue(EncodableValue(std::any_cast<RtpParametersMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
  }
  flutter::StandardCodecSerializer::WriteValue(value, stream);
}

/// The codec used by RTCRtpSenderApi.
const flutter::StandardMessageCodec& RTCRtpSenderApi::GetCodec() {
  return flutter::StandardMessageCodec::GetInstance(&RTCRtpSenderApiCodecSerializer::GetInstance());
}

// Sets up an instance of `RTCRtpSenderApi` to handle messages through the `binary_messenger`.
void RTCRtpSenderApi::SetUp(
  flutter::BinaryMessenger* binary_messenger,
  RTCRtpSenderApi* api) {
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCRtpSenderApi.setParameters", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_peer_connection_id_arg = args.at(0);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          const auto& encodable_rtp_sender_id_arg = args.at(1);
          if (encodable_rtp_sender_id_arg.IsNull()) {
            reply(WrapError("rtp_sender_id_arg unexpectedly null."));
            return;
          }
          const auto& rtp_sender_id_arg = std::get<std::string>(encodable_rtp_sender_id_arg);
          const auto& encodable_parameters_arg = args.at(2);
          if (encodable_parameters_arg.IsNull()) {
            reply(WrapError("parameters_arg unexpectedly null."));
            return;
          }
          const auto& parameters_arg = std::any_cast<const RtpParametersMessage&>(std::get<CustomEncodableValue>(encodable_parameters_arg));
          ErrorOr<bool> output = api->SetParameters(peer_connection_id_arg, rtp_sender_id_arg, parameters_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCRtpSenderApi.replaceTrack", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_peer_connection_id_arg = args.at(0);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          const auto& encodable_rtp_sender_id_arg = args.at(1);
          if (encodable_rtp_sender_id_arg.IsNull()) {
            reply(WrapError("rtp_sender_id_arg unexpectedly null."));
            return;
          }
          const auto& rtp_sender_id_arg = std::get<std::string>(encodable_rtp_sender_id_arg);
          const auto& encodable_track_id_arg = args.at(2);
          if (encodable_track_id_arg.IsNull()) {
            reply(WrapError("track_id_arg unexpectedly null."));
            return;
          }
          const auto& track_id_arg = std::get<std::string>(encodable_track_id_arg);
          std::optional<FlutterError> output = api->ReplaceTrack(peer_connection_id_arg, rtp_sender_id_arg, track_id_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCRtpSenderApi.setTrack", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_peer_connection_id_arg = args.at(0);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          const auto& encodable_rtp_sender_id_arg = args.at(1);
          if (encodable_rtp_sender_id_arg.IsNull()) {
            reply(WrapError("rtp_sender_id_arg unexpectedly null."));
            return;
          }
          const auto& rtp_sender_id_arg = std::get<std::string>(encodable_rtp_sender_id_arg);
          const auto& encodable_track_id_arg = args.at(2);
          if (encodable_track_id_arg.IsNull()) {
            reply(WrapError("track_id_arg unexpectedly null."));
            return;
          }
          const auto& track_id_arg = std::get<std::string>(encodable_track_id_arg);
          const auto& encodable_take_ownership_arg = args.at(3);
          if (encodable_take_ownership_arg.IsNull()) {
            reply(WrapError("take_ownership_arg unexpectedly null."));
            return;
          }
          const auto& take_ownership_arg = std::get<bool>(encodable_take_ownership_arg);
          std::optional<FlutterError> output = api->SetTrack(peer_connection_id_arg, rtp_sender_id_arg, track_id_arg, take_ownership_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
}

EncodableValue RTCRtpSenderApi::WrapError(std::string_view error_message) {
  return EncodableValue(EncodableList{
    EncodableValue(std::string(error_message)),
    EncodableValue("Error"),
    EncodableValue()
  });
}

EncodableValue RTCRtpSenderApi::WrapError(const FlutterError& error) {
  return EncodableValue(EncodableList{
    EncodableValue(error.code()),
    EncodableValue(error.message()),
    error.details()
  });
}


RTCRtpTransceiverApiCodecSerializer::RTCRtpTransceiverApiCodecSerializer() {}

EncodableValue RTCRtpTransceiverApiCodecSerializer::ReadValueOfType(
  uint8_t type,
  flutter::ByteStreamReader* stream) const {
  switch (type) {
    case 128:
      return CustomEncodableValue(RtpCodecCapabilityMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    default:
      return flutter::StandardCodecSerializer::ReadValueOfType(type, stream);
  }
}

void RTCRtpTransceiverApiCodecSerializer::WriteValue(
  const EncodableValue& value,
  flutter::ByteStreamWriter* stream) const {
  if (const CustomEncodableValue* custom_value = std::get_if<CustomEncodableValue>(&value)) {
    if (custom_value->type() == typeid(RtpCodecCapabilityMessage)) {
      stream->WriteByte(128);
      WriteValue(EncodableValue(std::any_cast<RtpCodecCapabilityMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
  }
  flutter::StandardCodecSerializer::WriteValue(value, stream);
}

/// The codec used by RTCRtpTransceiverApi.
const flutter::StandardMessageCodec& RTCRtpTransceiverApi::GetCodec() {
  return flutter::StandardMessageCodec::GetInstance(&RTCRtpTransceiverApiCodecSerializer::GetInstance());
}

// Sets up an instance of `RTCRtpTransceiverApi` to handle messages through the `binary_messenger`.
void RTCRtpTransceiverApi::SetUp(
  flutter::BinaryMessenger* binary_messenger,
  RTCRtpTransceiverApi* api) {
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCRtpTransceiverApi.setDirection", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_peer_connection_id_arg = args.at(0);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          const auto& encodable_transceiver_id_arg = args.at(1);
          if (encodable_transceiver_id_arg.IsNull()) {
            reply(WrapError("transceiver_id_arg unexpectedly null."));
            return;
          }
          const auto& transceiver_id_arg = std::get<std::string>(encodable_transceiver_id_arg);
          const auto& encodable_direction_arg = args.at(2);
          if (encodable_direction_arg.IsNull()) {
            reply(WrapError("direction_arg unexpectedly null."));
            return;
          }
          const auto& direction_arg = std::get<std::string>(encodable_direction_arg);
          std::optional<FlutterError> output = api->SetDirection(peer_connection_id_arg, transceiver_id_arg, direction_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCRtpTransceiverApi.getCurrentDirection", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_peer_connection_id_arg = args.at(0);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          const auto& encodable_transceiver_id_arg = args.at(1);
          if (encodable_transceiver_id_arg.IsNull()) {
            reply(WrapError("transceiver_id_arg unexpectedly null."));
            return;
          }
          const auto& transceiver_id_arg = std::get<std::string>(encodable_transceiver_id_arg);
          ErrorOr<std::optional<std::string>> output = api->GetCurrentDirection(peer_connection_id_arg, transceiver_id_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          auto output_optional = std::move(output).TakeValue();
          if (output_optional) {
            wrapped.push_back(EncodableValue(std::move(output_optional).value()));
          } else {
            wrapped.push_back(EncodableValue());
          }
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCRtpTransceiverApi.getDirection", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_peer_connection_id_arg = args.at(0);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          const auto& encodable_transceiver_id_arg = args.at(1);
          if (encodable_transceiver_id_arg.IsNull()) {
            reply(WrapError("transceiver_id_arg unexpectedly null."));
            return;
          }
          const auto& transceiver_id_arg = std::get<std::string>(encodable_transceiver_id_arg);
          ErrorOr<std::string> output = api->GetDirection(peer_connection_id_arg, transceiver_id_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCRtpTransceiverApi.stopRtpTransceiver", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_peer_connection_id_arg = args.at(0);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          const auto& encodable_transceiver_id_arg = args.at(1);
          if (encodable_transceiver_id_arg.IsNull()) {
            reply(WrapError("transceiver_id_arg unexpectedly null."));
            return;
          }
          const auto& transceiver_id_arg = std::get<std::string>(encodable_transceiver_id_arg);
          std::optional<FlutterError> output = api->StopRtpTransceiver(peer_connection_id_arg, transceiver_id_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCRtpTransceiverApi.setCodecPreferences", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_peer_connection_id_arg = args.at(0);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          const auto& encodable_transceiver_id_arg = args.at(1);
          if (encodable_transceiver_id_arg.IsNull()) {
            reply(WrapError("transceiver_id_arg unexpectedly null."));
            return;
          }
          const auto& transceiver_id_arg = std::get<std::string>(encodable_transceiver_id_arg);
          const auto& encodable_codecs_arg = args.at(2);
          if (encodable_codecs_arg.IsNull()) {
            reply(WrapError("codecs_arg unexpectedly null."));
            return;
          }
          const auto& codecs_arg = std::get<EncodableList>(encodable_codecs_arg);
          std::optional<FlutterError> output = api->SetCodecPreferences(peer_connection_id_arg, transceiver_id_arg, codecs_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
}

EncodableValue RTCRtpTransceiverApi::WrapError(std::string_view error_message) {
  return EncodableValue(EncodableList{
    EncodableValue(std::string(error_message)),
    EncodableValue("Error"),
    EncodableValue()
  });
}

EncodableValue RTCRtpTransceiverApi::WrapError(const FlutterError& error) {
  return EncodableValue(EncodableList{
    EncodableValue(error.code()),
    EncodableValue(error.message()),
    error.details()
  });
}

/// The codec used by RTCVideoRendererApi.
const flutter::StandardMessageCodec& RTCVideoRendererApi::GetCodec() {
  return flutter::StandardMessageCodec::GetInstance(&flutter::StandardCodecSerializer::GetInstance());
}

// Sets up an instance of `RTCVideoRendererApi` to handle messages through the `binary_messenger`.
void RTCVideoRendererApi::SetUp(
  flutter::BinaryMessenger* binary_messenger,
  RTCVideoRendererApi* api) {
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCVideoRendererApi.initialize", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          ErrorOr<std::optional<int64_t>> output = api->Initialize();
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          auto output_optional = std::move(output).TakeValue();
          if (output_optional) {
            wrapped.push_back(EncodableValue(std::move(output_optional).value()));
          } else {
            wrapped.push_back(EncodableValue());
          }
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCVideoRendererApi.setSrcObject", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_texture_id_arg = args.at(0);
          if (encodable_texture_id_arg.IsNull()) {
            reply(WrapError("texture_id_arg unexpectedly null."));
            return;
          }
          const int64_t texture_id_arg = encodable_texture_id_arg.LongValue();
          const auto& encodable_stream_id_arg = args.at(1);
          if (encodable_stream_id_arg.IsNull()) {
            reply(WrapError("stream_id_arg unexpectedly null."));
            return;
          }
          const auto& stream_id_arg = std::get<std::string>(encodable_stream_id_arg);
          const auto& encodable_owner_tag_arg = args.at(2);
          if (encodable_owner_tag_arg.IsNull()) {
            reply(WrapError("owner_tag_arg unexpectedly null."));
            return;
          }
          const auto& owner_tag_arg = std::get<std::string>(encodable_owner_tag_arg);
          const auto& encodable_track_id_arg = args.at(3);
          const auto* track_id_arg = std::get_if<std::string>(&encodable_track_id_arg);
          std::optional<FlutterError> output = api->SetSrcObject(texture_id_arg, stream_id_arg, owner_tag_arg, track_id_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.RTCVideoRendererApi.disposeVideoRender", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_texture_id_arg = args.at(0);
          if (encodable_texture_id_arg.IsNull()) {
            reply(WrapError("texture_id_arg unexpectedly null."));
            return;
          }
          const int64_t texture_id_arg = encodable_texture_id_arg.LongValue();
          std::optional<FlutterError> output = api->DisposeVideoRender(texture_id_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
}

EncodableValue RTCVideoRendererApi::WrapError(std::string_view error_message) {
  return EncodableValue(EncodableList{
    EncodableValue(std::string(error_message)),
    EncodableValue("Error"),
    EncodableValue()
  });
}

EncodableValue RTCVideoRendererApi::WrapError(const FlutterError& error) {
  return EncodableValue(EncodableList{
    EncodableValue(error.code()),
    EncodableValue(error.message()),
    error.details()
  });
}

/// The codec used by MediaRecorderApi.
const flutter::StandardMessageCodec& MediaRecorderApi::GetCodec() {
  return flutter::StandardMessageCodec::GetInstance(&flutter::StandardCodecSerializer::GetInstance());
}

// Sets up an instance of `MediaRecorderApi` to handle messages through the `binary_messenger`.
void MediaRecorderApi::SetUp(
  flutter::BinaryMessenger* binary_messenger,
  MediaRecorderApi* api) {
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.MediaRecorderApi.start", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_path_arg = args.at(0);
          if (encodable_path_arg.IsNull()) {
            reply(WrapError("path_arg unexpectedly null."));
            return;
          }
          const auto& path_arg = std::get<std::string>(encodable_path_arg);
          const auto& encodable_audio_channel_arg = args.at(1);
          if (encodable_audio_channel_arg.IsNull()) {
            reply(WrapError("audio_channel_arg unexpectedly null."));
            return;
          }
          const int64_t audio_channel_arg = encodable_audio_channel_arg.LongValue();
          const auto& encodable_video_track_id_arg = args.at(2);
          const auto* video_track_id_arg = std::get_if<std::string>(&encodable_video_track_id_arg);
          const auto& encodable_recorder_id_arg = args.at(3);
          if (encodable_recorder_id_arg.IsNull()) {
            reply(WrapError("recorder_id_arg unexpectedly null."));
            return;
          }
          const int64_t recorder_id_arg = encodable_recorder_id_arg.LongValue();
          const auto& encodable_peer_connection_id_arg = args.at(4);
          const auto* peer_connection_id_arg = std::get_if<std::string>(&encodable_peer_connection_id_arg);
          std::optional<FlutterError> output = api->Start(path_arg, audio_channel_arg, video_track_id_arg, recorder_id_arg, peer_connection_id_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.MediaRecorderApi.stopMediaRecorder", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_recorder_id_arg = args.at(0);
          if (encodable_recorder_id_arg.IsNull()) {
            reply(WrapError("recorder_id_arg unexpectedly null."));
            return;
          }
          const int64_t recorder_id_arg = encodable_recorder_id_arg.LongValue();
          std::optional<FlutterError> output = api->StopMediaRecorder(recorder_id_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
}

EncodableValue MediaRecorderApi::WrapError(std::string_view error_message) {
  return EncodableValue(EncodableList{
    EncodableValue(std::string(error_message)),
    EncodableValue("Error"),
    EncodableValue()
  });
}

EncodableValue MediaRecorderApi::WrapError(const FlutterError& error) {
  return EncodableValue(EncodableList{
    EncodableValue(error.code()),
    EncodableValue(error.message()),
    error.details()
  });
}

/// The codec used by MediaStreamApi.
const flutter::StandardMessageCodec& MediaStreamApi::GetCodec() {
  return flutter::StandardMessageCodec::GetInstance(&flutter::StandardCodecSerializer::GetInstance());
}

// Sets up an instance of `MediaStreamApi` to handle messages through the `binary_messenger`.
void MediaStreamApi::SetUp(
  flutter::BinaryMessenger* binary_messenger,
  MediaStreamApi* api) {
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.MediaStreamApi.getMediaStreamTracks", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_stream_id_arg = args.at(0);
          if (encodable_stream_id_arg.IsNull()) {
            reply(WrapError("stream_id_arg unexpectedly null."));
            return;
          }
          const auto& stream_id_arg = std::get<std::string>(encodable_stream_id_arg);
          std::optional<FlutterError> output = api->GetMediaStreamTracks(stream_id_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.MediaStreamApi.addMediaStreamTrack", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_stream_id_arg = args.at(0);
          if (encodable_stream_id_arg.IsNull()) {
            reply(WrapError("stream_id_arg unexpectedly null."));
            return;
          }
          const auto& stream_id_arg = std::get<std::string>(encodable_stream_id_arg);
          const auto& encodable_track_id_arg = args.at(1);
          if (encodable_track_id_arg.IsNull()) {
            reply(WrapError("track_id_arg unexpectedly null."));
            return;
          }
          const auto& track_id_arg = std::get<std::string>(encodable_track_id_arg);
          std::optional<FlutterError> output = api->AddMediaStreamTrack(stream_id_arg, track_id_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.MediaStreamApi.removeMediaStreamTrack", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_stream_id_arg = args.at(0);
          if (encodable_stream_id_arg.IsNull()) {
            reply(WrapError("stream_id_arg unexpectedly null."));
            return;
          }
          const auto& stream_id_arg = std::get<std::string>(encodable_stream_id_arg);
          const auto& encodable_track_id_arg = args.at(1);
          if (encodable_track_id_arg.IsNull()) {
            reply(WrapError("track_id_arg unexpectedly null."));
            return;
          }
          const auto& track_id_arg = std::get<std::string>(encodable_track_id_arg);
          std::optional<FlutterError> output = api->RemoveMediaStreamTrack(stream_id_arg, track_id_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.MediaStreamApi.disposeMediaStream", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_stream_id_arg = args.at(0);
          if (encodable_stream_id_arg.IsNull()) {
            reply(WrapError("stream_id_arg unexpectedly null."));
            return;
          }
          const auto& stream_id_arg = std::get<std::string>(encodable_stream_id_arg);
          std::optional<FlutterError> output = api->DisposeMediaStream(stream_id_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
}

EncodableValue MediaStreamApi::WrapError(std::string_view error_message) {
  return EncodableValue(EncodableList{
    EncodableValue(std::string(error_message)),
    EncodableValue("Error"),
    EncodableValue()
  });
}

EncodableValue MediaStreamApi::WrapError(const FlutterError& error) {
  return EncodableValue(EncodableList{
    EncodableValue(error.code()),
    EncodableValue(error.message()),
    error.details()
  });
}

/// The codec used by MediaStreamTrackApi.
const flutter::StandardMessageCodec& MediaStreamTrackApi::GetCodec() {
  return flutter::StandardMessageCodec::GetInstance(&flutter::StandardCodecSerializer::GetInstance());
}

// Sets up an instance of `MediaStreamTrackApi` to handle messages through the `binary_messenger`.
void MediaStreamTrackApi::SetUp(
  flutter::BinaryMessenger* binary_messenger,
  MediaStreamTrackApi* api) {
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.MediaStreamTrackApi.enable", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_track_id_arg = args.at(0);
          if (encodable_track_id_arg.IsNull()) {
            reply(WrapError("track_id_arg unexpectedly null."));
            return;
          }
          const auto& track_id_arg = std::get<std::string>(encodable_track_id_arg);
          const auto& encodable_enabled_arg = args.at(1);
          if (encodable_enabled_arg.IsNull()) {
            reply(WrapError("enabled_arg unexpectedly null."));
            return;
          }
          const auto& enabled_arg = std::get<bool>(encodable_enabled_arg);
          const auto& encodable_peer_connection_id_arg = args.at(2);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          std::optional<FlutterError> output = api->Enable(track_id_arg, enabled_arg, peer_connection_id_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.MediaStreamTrackApi.hasTorch", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_track_id_arg = args.at(0);
          if (encodable_track_id_arg.IsNull()) {
            reply(WrapError("track_id_arg unexpectedly null."));
            return;
          }
          const auto& track_id_arg = std::get<std::string>(encodable_track_id_arg);
          ErrorOr<bool> output = api->HasTorch(track_id_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.MediaStreamTrackApi.setTorch", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_track_id_arg = args.at(0);
          if (encodable_track_id_arg.IsNull()) {
            reply(WrapError("track_id_arg unexpectedly null."));
            return;
          }
          const auto& track_id_arg = std::get<std::string>(encodable_track_id_arg);
          const auto& encodable_torch_arg = args.at(1);
          if (encodable_torch_arg.IsNull()) {
            reply(WrapError("torch_arg unexpectedly null."));
            return;
          }
          const auto& torch_arg = std::get<bool>(encodable_torch_arg);
          std::optional<FlutterError> output = api->SetTorch(track_id_arg, torch_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.MediaStreamTrackApi.captureFrame", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_track_id_arg = args.at(0);
          if (encodable_track_id_arg.IsNull()) {
            reply(WrapError("track_id_arg unexpectedly null."));
            return;
          }
          const auto& track_id_arg = std::get<std::string>(encodable_track_id_arg);
          const auto& encodable_peer_connection_id_arg = args.at(1);
          if (encodable_peer_connection_id_arg.IsNull()) {
            reply(WrapError("peer_connection_id_arg unexpectedly null."));
            return;
          }
          const auto& peer_connection_id_arg = std::get<std::string>(encodable_peer_connection_id_arg);
          const auto& encodable_path_arg = args.at(2);
          if (encodable_path_arg.IsNull()) {
            reply(WrapError("path_arg unexpectedly null."));
            return;
          }
          const auto& path_arg = std::get<std::string>(encodable_path_arg);
          std::optional<FlutterError> output = api->CaptureFrame(track_id_arg, peer_connection_id_arg, path_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.MediaStreamTrackApi.stopMediaStreamTrack", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_track_id_arg = args.at(0);
          if (encodable_track_id_arg.IsNull()) {
            reply(WrapError("track_id_arg unexpectedly null."));
            return;
          }
          const auto& track_id_arg = std::get<std::string>(encodable_track_id_arg);
          std::optional<FlutterError> output = api->StopMediaStreamTrack(track_id_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
}

EncodableValue MediaStreamTrackApi::WrapError(std::string_view error_message) {
  return EncodableValue(EncodableList{
    EncodableValue(std::string(error_message)),
    EncodableValue("Error"),
    EncodableValue()
  });
}

EncodableValue MediaStreamTrackApi::WrapError(const FlutterError& error) {
  return EncodableValue(EncodableList{
    EncodableValue(error.code()),
    EncodableValue(error.message()),
    error.details()
  });
}


DesktopCapturerSourceApiCodecSerializer::DesktopCapturerSourceApiCodecSerializer() {}

EncodableValue DesktopCapturerSourceApiCodecSerializer::ReadValueOfType(
  uint8_t type,
  flutter::ByteStreamReader* stream) const {
  switch (type) {
    case 128:
      return CustomEncodableValue(DesktopCapturerSourceMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 129:
      return CustomEncodableValue(ThumbnailSizeMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    default:
      return flutter::StandardCodecSerializer::ReadValueOfType(type, stream);
  }
}

void DesktopCapturerSourceApiCodecSerializer::WriteValue(
  const EncodableValue& value,
  flutter::ByteStreamWriter* stream) const {
  if (const CustomEncodableValue* custom_value = std::get_if<CustomEncodableValue>(&value)) {
    if (custom_value->type() == typeid(DesktopCapturerSourceMessage)) {
      stream->WriteByte(128);
      WriteValue(EncodableValue(std::any_cast<DesktopCapturerSourceMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(ThumbnailSizeMessage)) {
      stream->WriteByte(129);
      WriteValue(EncodableValue(std::any_cast<ThumbnailSizeMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
  }
  flutter::StandardCodecSerializer::WriteValue(value, stream);
}

/// The codec used by DesktopCapturerSourceApi.
const flutter::StandardMessageCodec& DesktopCapturerSourceApi::GetCodec() {
  return flutter::StandardMessageCodec::GetInstance(&DesktopCapturerSourceApiCodecSerializer::GetInstance());
}

// Sets up an instance of `DesktopCapturerSourceApi` to handle messages through the `binary_messenger`.
void DesktopCapturerSourceApi::SetUp(
  flutter::BinaryMessenger* binary_messenger,
  DesktopCapturerSourceApi* api) {
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.DesktopCapturerSourceApi.getDesktopSources", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_types_arg = args.at(0);
          if (encodable_types_arg.IsNull()) {
            reply(WrapError("types_arg unexpectedly null."));
            return;
          }
          const auto& types_arg = std::get<EncodableList>(encodable_types_arg);
          const auto& encodable_thumbnail_size_arg = args.at(1);
          if (encodable_thumbnail_size_arg.IsNull()) {
            reply(WrapError("thumbnail_size_arg unexpectedly null."));
            return;
          }
          const auto& thumbnail_size_arg = std::any_cast<const ThumbnailSizeMessage&>(std::get<CustomEncodableValue>(encodable_thumbnail_size_arg));
          ErrorOr<EncodableList> output = api->GetDesktopSources(types_arg, thumbnail_size_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.DesktopCapturerSourceApi.updateSources", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_types_arg = args.at(0);
          if (encodable_types_arg.IsNull()) {
            reply(WrapError("types_arg unexpectedly null."));
            return;
          }
          const auto& types_arg = std::get<EncodableList>(encodable_types_arg);
          ErrorOr<bool> output = api->UpdateSources(types_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.DesktopCapturerSourceApi.getThumbnail", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_source_id_arg = args.at(0);
          if (encodable_source_id_arg.IsNull()) {
            reply(WrapError("source_id_arg unexpectedly null."));
            return;
          }
          const auto& source_id_arg = std::get<std::string>(encodable_source_id_arg);
          const auto& encodable_thumbnail_size_arg = args.at(1);
          if (encodable_thumbnail_size_arg.IsNull()) {
            reply(WrapError("thumbnail_size_arg unexpectedly null."));
            return;
          }
          const auto& thumbnail_size_arg = std::any_cast<const ThumbnailSizeMessage&>(std::get<CustomEncodableValue>(encodable_thumbnail_size_arg));
          ErrorOr<std::optional<std::vector<uint8_t>>> output = api->GetThumbnail(source_id_arg, thumbnail_size_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          auto output_optional = std::move(output).TakeValue();
          if (output_optional) {
            wrapped.push_back(EncodableValue(std::move(output_optional).value()));
          } else {
            wrapped.push_back(EncodableValue());
          }
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
}

EncodableValue DesktopCapturerSourceApi::WrapError(std::string_view error_message) {
  return EncodableValue(EncodableList{
    EncodableValue(std::string(error_message)),
    EncodableValue("Error"),
    EncodableValue()
  });
}

EncodableValue DesktopCapturerSourceApi::WrapError(const FlutterError& error) {
  return EncodableValue(EncodableList{
    EncodableValue(error.code()),
    EncodableValue(error.message()),
    error.details()
  });
}


MediaDevicesApiCodecSerializer::MediaDevicesApiCodecSerializer() {}

EncodableValue MediaDevicesApiCodecSerializer::ReadValueOfType(
  uint8_t type,
  flutter::ByteStreamReader* stream) const {
  switch (type) {
    case 128:
      return CustomEncodableValue(AudioTrackMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 129:
      return CustomEncodableValue(AudioTrackSettingsMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 130:
      return CustomEncodableValue(ConfigurationMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 131:
      return CustomEncodableValue(ConstraintsMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 132:
      return CustomEncodableValue(DataChannelInitMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 133:
      return CustomEncodableValue(DataChannelMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 134:
      return CustomEncodableValue(DesktopCapturerSourceMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 135:
      return CustomEncodableValue(HeaderExtensionMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 136:
      return CustomEncodableValue(IceCandidateMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 137:
      return CustomEncodableValue(MediaDeviceInfoMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 138:
      return CustomEncodableValue(MediaStreamMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 139:
      return CustomEncodableValue(RTCParametersMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 140:
      return CustomEncodableValue(RtpCapabilitiesMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 141:
      return CustomEncodableValue(RtpCodecCapabilityMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 142:
      return CustomEncodableValue(RtpCodecMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 143:
      return CustomEncodableValue(RtpEncodingMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 144:
      return CustomEncodableValue(RtpHeaderExtensionCapabilityMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 145:
      return CustomEncodableValue(RtpParametersMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 146:
      return CustomEncodableValue(SessionDescriptionMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 147:
      return CustomEncodableValue(StatsReportMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 148:
      return CustomEncodableValue(ThumbnailSizeMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 149:
      return CustomEncodableValue(VideoTrackMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 150:
      return CustomEncodableValue(VideoTrackSettingsMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    default:
      return flutter::StandardCodecSerializer::ReadValueOfType(type, stream);
  }
}

void MediaDevicesApiCodecSerializer::WriteValue(
  const EncodableValue& value,
  flutter::ByteStreamWriter* stream) const {
  if (const CustomEncodableValue* custom_value = std::get_if<CustomEncodableValue>(&value)) {
    if (custom_value->type() == typeid(AudioTrackMessage)) {
      stream->WriteByte(128);
      WriteValue(EncodableValue(std::any_cast<AudioTrackMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(AudioTrackSettingsMessage)) {
      stream->WriteByte(129);
      WriteValue(EncodableValue(std::any_cast<AudioTrackSettingsMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(ConfigurationMessage)) {
      stream->WriteByte(130);
      WriteValue(EncodableValue(std::any_cast<ConfigurationMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(ConstraintsMessage)) {
      stream->WriteByte(131);
      WriteValue(EncodableValue(std::any_cast<ConstraintsMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(DataChannelInitMessage)) {
      stream->WriteByte(132);
      WriteValue(EncodableValue(std::any_cast<DataChannelInitMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(DataChannelMessage)) {
      stream->WriteByte(133);
      WriteValue(EncodableValue(std::any_cast<DataChannelMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(DesktopCapturerSourceMessage)) {
      stream->WriteByte(134);
      WriteValue(EncodableValue(std::any_cast<DesktopCapturerSourceMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(HeaderExtensionMessage)) {
      stream->WriteByte(135);
      WriteValue(EncodableValue(std::any_cast<HeaderExtensionMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(IceCandidateMessage)) {
      stream->WriteByte(136);
      WriteValue(EncodableValue(std::any_cast<IceCandidateMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(MediaDeviceInfoMessage)) {
      stream->WriteByte(137);
      WriteValue(EncodableValue(std::any_cast<MediaDeviceInfoMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(MediaStreamMessage)) {
      stream->WriteByte(138);
      WriteValue(EncodableValue(std::any_cast<MediaStreamMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(RTCParametersMessage)) {
      stream->WriteByte(139);
      WriteValue(EncodableValue(std::any_cast<RTCParametersMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(RtpCapabilitiesMessage)) {
      stream->WriteByte(140);
      WriteValue(EncodableValue(std::any_cast<RtpCapabilitiesMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(RtpCodecCapabilityMessage)) {
      stream->WriteByte(141);
      WriteValue(EncodableValue(std::any_cast<RtpCodecCapabilityMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(RtpCodecMessage)) {
      stream->WriteByte(142);
      WriteValue(EncodableValue(std::any_cast<RtpCodecMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(RtpEncodingMessage)) {
      stream->WriteByte(143);
      WriteValue(EncodableValue(std::any_cast<RtpEncodingMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(RtpHeaderExtensionCapabilityMessage)) {
      stream->WriteByte(144);
      WriteValue(EncodableValue(std::any_cast<RtpHeaderExtensionCapabilityMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(RtpParametersMessage)) {
      stream->WriteByte(145);
      WriteValue(EncodableValue(std::any_cast<RtpParametersMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(SessionDescriptionMessage)) {
      stream->WriteByte(146);
      WriteValue(EncodableValue(std::any_cast<SessionDescriptionMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(StatsReportMessage)) {
      stream->WriteByte(147);
      WriteValue(EncodableValue(std::any_cast<StatsReportMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(ThumbnailSizeMessage)) {
      stream->WriteByte(148);
      WriteValue(EncodableValue(std::any_cast<ThumbnailSizeMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(VideoTrackMessage)) {
      stream->WriteByte(149);
      WriteValue(EncodableValue(std::any_cast<VideoTrackMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(VideoTrackSettingsMessage)) {
      stream->WriteByte(150);
      WriteValue(EncodableValue(std::any_cast<VideoTrackSettingsMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
  }
  flutter::StandardCodecSerializer::WriteValue(value, stream);
}

/// The codec used by MediaDevicesApi.
const flutter::StandardMessageCodec& MediaDevicesApi::GetCodec() {
  return flutter::StandardMessageCodec::GetInstance(&MediaDevicesApiCodecSerializer::GetInstance());
}

// Sets up an instance of `MediaDevicesApi` to handle messages through the `binary_messenger`.
void MediaDevicesApi::SetUp(
  flutter::BinaryMessenger* binary_messenger,
  MediaDevicesApi* api) {
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.MediaDevicesApi.getUserMedia", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_media_constraints_arg = args.at(0);
          if (encodable_media_constraints_arg.IsNull()) {
            reply(WrapError("media_constraints_arg unexpectedly null."));
            return;
          }
          const auto& media_constraints_arg = std::get<EncodableMap>(encodable_media_constraints_arg);
          ErrorOr<MediaStreamMessage> output = api->GetUserMedia(media_constraints_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.MediaDevicesApi.getDisplayMedia", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_media_constraints_arg = args.at(0);
          if (encodable_media_constraints_arg.IsNull()) {
            reply(WrapError("media_constraints_arg unexpectedly null."));
            return;
          }
          const auto& media_constraints_arg = std::get<EncodableMap>(encodable_media_constraints_arg);
          ErrorOr<MediaStreamMessage> output = api->GetDisplayMedia(media_constraints_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.MediaDevicesApi.getSources", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          ErrorOr<EncodableList> output = api->GetSources();
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.MediaDevicesApi.enumerateDevices", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          ErrorOr<EncodableList> output = api->EnumerateDevices();
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(binary_messenger, "dev.flutter.pigeon.MediaDevicesApi.selectAudioOutput", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_device_id_arg = args.at(0);
          if (encodable_device_id_arg.IsNull()) {
            reply(WrapError("device_id_arg unexpectedly null."));
            return;
          }
          const auto& device_id_arg = std::get<std::string>(encodable_device_id_arg);
          ErrorOr<MediaDeviceInfoMessage> output = api->SelectAudioOutput(device_id_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
}

EncodableValue MediaDevicesApi::WrapError(std::string_view error_message) {
  return EncodableValue(EncodableList{
    EncodableValue(std::string(error_message)),
    EncodableValue("Error"),
    EncodableValue()
  });
}

EncodableValue MediaDevicesApi::WrapError(const FlutterError& error) {
  return EncodableValue(EncodableList{
    EncodableValue(error.code()),
    EncodableValue(error.message()),
    error.details()
  });
}

}  // namespace flutter_webrtc_plugin
